#import "time.bah"

#import "./graphics.bah"

const uiEventElementAdded      = 1024
const uiEventElementHoverIn    = 1025
const uiEventElementHoverOut   = 1026
const uiEventElementClicked    = 1027
const uiEventElementFocusIn    = 1028
const uiEventElementFocusOut   = 1029
const uiEventElementHovered    = 1030
const uiEventElementMouseDown  = 1031

const uiNotDrawnEvents = []uint{
    uiEventElementHovered
}

#import "./elements/base.bah"

#define usleep(us uint)

#define __uiHandleEvents(ui window*, event uint32)
#define __uiSetElementOnFocus(ui window*, elem uiElement*)
#define __uiAnimationHandler(ui window*)

struct uiAnimation {
    time: uint
    freq: uint
    duration: uint
    elem: uiElement*
    processed: bool
}

struct ui extend window {
    font: font
    elements: []uiElement*
    focusedElement: uiElement*

    animations: []uiAnimation
    animationsMutex: mutex
    animationsCond: mutexCondition

    frameStart: uint
    isDrawing: bool

    alreadyDrawn: bool
    needsRedraw: bool
    isPartialRedraw: bool

    _oldDimensions: [int,int]


    _init() {
        this.font = getSystemUIfont()
        this.events = __uiHandleEvents
        this.animationsMutex.init()
        this.animationsCond.init()
    }

    addElement(elem uiElement*) {
        elem.window = this
        this.elements[len(this.elements)] = elem
        if this.isExposed {
            if this.isDrawing == false {
                this.frameStart = getTimeUnix()
            }
            this.redraw()
        }
    }

    setFocus(elem uiElement*) {
        __uiSetElementOnFocus(this, elem)
    }
}

__uiPropagateUpdateElementMask(ui ui*, currElem uiElement*) {
    i=0; for i < len(currElem.elements), i++ {
        pos = currElem.elements[i].getPosition()
        size = currElem.elements[i].getSize()
        if currElem.elements[i].manualDrawingMode == false {
            ui.getRect(pos, size, currElem.elements[i].maskedBuffer)
        }
    }
}

__uiRedrawElement(ui ui*, elem uiElement*) {
    if ui.isDrawing == false {
        ui.frameStart = getTimeUnix()
        ui.isDrawing = true
    }
    ui.needsRedraw = true
    currElem = elem
    for currElem != null, currElem = currElem.parent {
        if currElem.hashChanged() == false {
            ui.alreadyDrawn = true
            drawFn = currElem._draw
            if drawFn != null {

                os = ui.scissor
                if elem.parent != null {
                    scissor = [0,0,0,0]

                    currBox = elem.parent
                    for currBox != null, currBox = currBox.parent {
                        size = currBox.getSize()
                        pos = currBox.getPosition()

                        if scissor[2] + scissor[3] == 0 {
                            scissor[0] = pos[0]
                            scissor[1] = pos[1]
                            scissor[2] = size[0]
                            scissor[3] = size[1]
                            continue
                        }

                        if pos[0] > scissor[0] {
                            scissor[0] = pos[0]
                        }

                        if pos[1] > scissor[1] {
                            scissor[1] = pos[1]
                        }

                        if size[0] < scissor[2] {
                            scissor[2] = size[0]
                        }

                        if size[1] < scissor[3] {
                            scissor[3] = size[1]
                        }
                    }

                    ui.setScissor([scissor[0], scissor[1]], [scissor[2], scissor[3]])
                } else {
                    ui.disableScissor()
                }

                pos = currElem.getPosition()
                size = currElem.getSize()
                if currElem.manualDrawingMode == false {
                    if ui.scissor[0] != false {
                        if pos[0] < ui.scissor[1] {
                            pos[0] = ui.scissor[1]
                        } else if pos[1] < ui.scissor[2] {
                            pos[1] = ui.scissor[2]
                        }
                    }
                    ui.drawRectImage(pos, size, currElem.maskedBuffer)
                }

                drawFn(currElem, ui)
                __uiPropagateUpdateElementMask(ui, currElem)

                ui.scissor = os

                i=0; for i < len(currElem.elements), i++ {
                    __uiRedrawElement(ui, currElem.elements[i])
                }
                break
            }
        } else {

            os = ui.scissor
            if elem.parent != null {
                scissor = [0,0,0,0]

                currBox = elem.parent
                for currBox != null, currBox = currBox.parent {
                    size = currBox.getSize()
                    pos = currBox.getPosition()

                    if scissor[2] + scissor[3] == 0 {
                        scissor[0] = pos[0]
                        scissor[1] = pos[1]
                        scissor[2] = size[0]
                        scissor[3] = size[1]
                        continue
                    }

                    if pos[0] > scissor[0] {
                        scissor[0] = pos[0]
                    }

                    if pos[1] > scissor[1] {
                        scissor[1] = pos[1]
                    }

                    if size[0] < scissor[2] {
                        scissor[2] = size[0]
                    }

                    if size[1] < scissor[3] {
                        scissor[3] = size[1]
                    }
                }

                ui.setScissor([scissor[0], scissor[1]], [scissor[2], scissor[3]])
            } else {
                ui.disableScissor()
            }

            elem.captureMaskedBuffer()

            ui.scissor = os
        }
    }

    if currElem == null {
        ui.alreadyDrawn = false
    }

}

__uiRedrawElementDelayed(ui ui*, elem uiElement*, ms uint) {
    now = getTimeUnix() / 1000000
    i=0; for i < len(ui.animations), i++ {
        anim = &ui.animations[i]
        if anim.elem == elem && anim.processed == false {
            anim.freq = ms
            return
        }
    }

    ui.animations[len(ui.animations)] = uiAnimation {
        time: now
        freq: ms
        elem: elem
    }

    ui.animationsCond.send()
}

__uiAnimationHandler(ui ui*) {
    freq = 40
    for ui.isRunning {
        ui.animationsMutex.lock()
        // println("waiting: "+uintToStr(freq)+"ms")
        if len(ui.animations) == 0 {
            ui.animationsCond.wait(ui.animationsMutex)
        } else {
            ui.animationsMutex.unlock()
            usleep(freq * 1000)
            ui.animationsMutex.lock()
        }
        


        if ui.needsRedraw {
            ui.animationsMutex.unlock()
            continue
        }

        now = getTimeUnix() / 1000000
        freq = 40
        found = false
        i=len(ui.animations) - 1; for i != -1, i-- {
            anim = &ui.animations[i]
            if anim.freq < 250 && (anim.freq < freq || i == len(ui.animations) - 1) {
                freq = anim.freq
            }
            
            if <int>(anim.freq + anim.time) - now <= 30 && anim.processed == false {
                anim.processed = true
                found = true
                break
            }
            // println("noep ["+intToStr(i)+"]: "+intToStr(anim.freq + anim.time)+" > "+intToStr(now)+" processed ? "+intToStr(<int>anim.processed))
        }

        if found {
            ui.isPartialRedraw = true
            ui.redraw()
        }
        ui.animationsMutex.unlock()
    }
    ui.animationsMutex.destroy()
    ui.animationsCond.destroy()

}

__uiDispatchEvent(ui ui*, elem uiElement*, event uint32) {
    currElem = elem
    fn = currElem._events
    if fn != null {
        fn(currElem, event)
    }

    // if elem.manualDrawingMode == false {
    if event in uiNotDrawnEvents == false {
        __uiRedrawElement(ui, elem)
    }
    // }
}

_uiElementRecusriveRemove(elem uiElement*, ui ui*, forceRemove bool) bool {
    toRemove = forceRemove || elem.toRemove
    hasRemoved = false
    i=0; for i < len(elem.elements), i++ {
        if _uiElementRecusriveRemove(elem.elements[i], ui, toRemove) {
            if forceRemove == false {

                if elem.elements[i].hashChanged() == false && elem.elements[i].manualDrawingMode == false {
                    pos = elem.elements[i].getPosition()
                    size = elem.elements[i].getSize()
                    ui.drawRectImage(pos, size, elem.elements[i].maskedBuffer)
                } else {
                    hasRemoved = true
                }

                j=len(ui.animations) - 1; for j != -1, j-- {
                    anim = &ui.animations[j]
                    if anim.elem == elem.elements[i] {
                        delete(ui.animations, j)
                    }
                }

                delete(elem.elements, i)
                i--
            }
        }
    }

    if hasRemoved && toRemove == false {
        __uiRedrawElement(ui, elem)
    }

    return toRemove
}

_uiElementRecusriveResetHover(elem uiElement*, ui ui*) {
    wasHovered = elem.hovered
    elem.hovered = false
    if wasHovered {
        __uiRedrawElement(ui, elem)
        __uiDispatchEvent(ui, elem, uiEventElementHoverOut)
    }
    
    i=0; for i < len(elem.elements), i++ {
        _uiElementRecusriveResetHover(elem.elements[i], ui)
    }
}

_uiElementRecusriveHover(elem uiElement*, ui ui*, pos [int,int]) [uiElement*, uint, bool] {
    elemPos = elem.getPosition()
    elemSize = elem.getSize()
    cursorChanged = false
    nb = 0
    if pos[0] >= elemPos[0] && pos[0] < elemPos[0] + elemSize[0] {
        if pos[1] >= elemPos[1] && pos[1] < elemPos[1] + elemSize[1] {
            wasHovered = elem.hovered
            elem.hovered = true
            nb++
            i=0; for i < len(elem.elements), i++ {
                childCons = _uiElementRecusriveHover(elem.elements[i], ui, pos)
                nb += childCons[1]
                if childCons[2] {
                    cursorChanged = true
                }
                if childCons[0] != null {
                    if len(childCons[0].cursor) != 0 {
                        ui.setCursor(childCons[0].cursor)
                        cursorChanged = true
                    }
                    __uiDispatchEvent(ui, childCons[0], uiEventElementHoverIn)
                }
            }

            if wasHovered {
                __uiDispatchEvent(ui, elem, uiEventElementHovered)
                if len(elem.cursor) != 0 {
                    cursorChanged = true
                }

                return [null, nb, cursorChanged]
            }

            if len(elem.cursor) != 0 {
                ui.setCursor(elem.cursor)
                cursorChanged = true
            }
            __uiDispatchEvent(ui, elem, uiEventElementHoverIn)

            return [elem, nb, cursorChanged]
        }
    }
    _uiElementRecusriveResetHover(elem, ui)
    return [null, nb, false]
}

_uiElementRecusriveCollide(elem uiElement*, pos [int,int]) uiElement* {
    elemPos = elem.getPosition()
    elemSize = elem.getSize()
    if pos[0] >= elemPos[0] && pos[0] < elemPos[0] + elemSize[0] {
        if pos[1] >= elemPos[1] && pos[1] < elemPos[1] + elemSize[1] {
            if elem.focusable {
                return elem
            }

            i=0; for i < len(elem.elements), i++ {
                ce = _uiElementRecusriveCollide(elem.elements[i], pos)
                if ce != null && ce.focusable {
                    return ce
                }
            }
        }
    }
    return null
}

__ui_filterIsElemScrollable(elem uiElement*) bool {
    size = elem.getSize()
    
    innerSize = elem.getInnerSize()

    return innerSize[1] > size[1]
}

_uiElementRecusriveCollideFiltered(elem uiElement*, pos [int,int], filter function(uiElement*) bool) uiElement* {
    elemPos = elem.getPosition()
    elemSize = elem.getSize()
    if pos[0] >= elemPos[0] && pos[0] < elemPos[0] + elemSize[0] {
        if pos[1] >= elemPos[1] && pos[1] < elemPos[1] + elemSize[1] {
            i=0; for i < len(elem.elements), i++ {
                ce = _uiElementRecusriveCollideFiltered(elem.elements[i], pos, filter)
                if ce != null && filter(ce) {
                    return ce
                }
            }
            if filter(elem) {
                return elem
            }
        }
    }
    return null
}

__uiSetElementOnFocus(ui ui*, elem uiElement*) {
    if ui.focusedElement != null {
        ui.focusedElement.clicked = false
        __uiRedrawElement(ui, ui.focusedElement)
        ui.focusedElement.focused = false
        __uiDispatchEvent(ui, ui.focusedElement, uiEventElementFocusOut)
        ui.focusedElement = null
    }
    ui.focusedElement = elem
    ui.focusedElement.focused = true
    __uiDispatchEvent(ui, ui.focusedElement, uiEventElementFocusIn)
    elem.clicked = true
    __uiRedrawElement(ui, elem)
}

__uiForceDrawElement(ui ui*, elem uiElement*) {
    fn = elem._draw
    if fn != null {
        os = ui.scissor
        if elem.parent != null {
            scissor = [0,0,0,0]

            currBox = elem.parent
            for currBox != null, currBox = currBox.parent {
                size = currBox.getSize()
                pos = currBox.getPosition()

                if scissor[2] + scissor[3] == 0 {
                    scissor[0] = pos[0]
                    scissor[1] = pos[1]
                    scissor[2] = size[0]
                    scissor[3] = size[1]
                    continue
                }

                if pos[0] > scissor[0] {
                    scissor[0] = pos[0]
                }

                if pos[1] > scissor[1] {
                    scissor[1] = pos[1]
                }

                if size[0] < scissor[2] {
                    scissor[2] = size[0]
                }

                if size[1] < scissor[3] {
                    scissor[3] = size[1]
                }
            }

            ui.setScissor([scissor[0], scissor[1]], [scissor[2], scissor[3]])
        } else {
            ui.disableScissor()
        }
        
        fn(elem, ui)
        if elem.hashChanged() {
            elem.captureMaskedBuffer()
        }

        ui.scissor = os
    }

    i=0; for i < len(elem.elements), i++ {
        __uiForceDrawElement(ui, elem.elements[i])
    }
}

__uiHandleEvents(ui ui*, event uint32) {
    ui.animationsMutex.lock()
    if event == windowEventInitialize || event == windowEventDraw {
        if event == windowEventInitialize {
            ui.alreadyDrawn = false
            async __uiAnimationHandler(ui)
        }

        if ui.width != ui._oldDimensions[0] {
            ui._oldDimensions[0] = ui.width
            ui.alreadyDrawn = false
        }

        if ui.height != ui._oldDimensions[1] {
            ui._oldDimensions[1] = ui.height
            ui.alreadyDrawn = false
        }


        i=0; for i < len(ui.elements), i++ {
            if ui.elements[i].toRemove {
                _uiElementRecusriveRemove(ui.elements[i], ui, true)
                if ui.elements[i].hashChanged() == false && ui.elements[i].manualDrawingMode == false {
                    pos = ui.elements[i].getPosition()
                    size = ui.elements[i].getSize()
                    ui.drawRectImage(pos, size, ui.elements[i].maskedBuffer)
                } else {
                    ui.alreadyDrawn = false
                }
                j=len(ui.animations) - 1; for j != -1, j-- {
                    anim = &ui.animations[j]
                    if anim.elem == ui.elements[i] {
                        delete(ui.animations, j)
                    }
                }
                delete(ui.elements, i)
                //remove its animations
                //instead of full redraw, paint its bg mask
                i--
            } else {
                _uiElementRecusriveRemove(ui.elements[i], ui, false)
            }
        }


        onrd = ui.needsRedraw
        i=len(ui.animations) - 1; for i != -1, i-- {
            anim = &ui.animations[i]
            
            if anim.processed {
                absTime = anim.freq / 1000 + anim.time
                __uiRedrawElement(ui, anim.elem)
                delete(ui.animations, i)
            }
        }
        ui.needsRedraw = onrd

        if ui.alreadyDrawn == false && ui.isPartialRedraw == false {
            if ui.isDrawing == false {
                ui.frameStart = getTimeUnix()
                ui.isDrawing = true
            }
            ui.clear(WHITE)
            i=0; for i < len(ui.elements), i++ {
                __uiForceDrawElement(ui, ui.elements[i])
            }
        }
        
        #debug {
            if ui.isDrawing {
                ui.isDrawing = false
                totalTime = (getTimeUnix() - ui.frameStart)
                ms = totalTime / 1000000
                fps = 1000000000 / totalTime
                println("frame:\t"+intToStr(ms)+"ms\t"+intToStr(fps)+"fps")

            }
        }
        ui.isPartialRedraw = false
    }

    if event == windowEventKeyDown || event == windowEventKeyUp {
        if ui.focusedElement != null {
            __uiDispatchEvent(ui, ui.focusedElement, event)
        }
    } else if event == windowEventMouseMove {
        pos = ui.getCursorPosition()
        nb = 0
        cursorChanged = false
        i=0; for i < len(ui.elements), i++ {
            elems = _uiElementRecusriveHover(ui.elements[i], ui, pos)
            nb += elems[1]
            if elems[2] {
                cursorChanged = true
            }
            if elems[0] != null {
                break
            }
        }

        if nb == 0 || cursorChanged == false {
            ui.setCursor("left_ptr")
        }
    }else if event == windowEventMouseDown {
        pos = ui.getCursorPosition()
        clickedBtn = ui.getEventButton()
        if clickedBtn == MOUSE_LEFT_BUTTON {
            i=0; for i < len(ui.elements), i++ {
                elem = _uiElementRecusriveCollide(ui.elements[i], pos)
                if elem != null {
                    __uiDispatchEvent(ui, elem, uiEventElementMouseDown)
                    __uiSetElementOnFocus(ui, elem)
                    break
                }
            }
        } else if clickedBtn == MOUSE_SCROLL_DOWN {
            i=0; for i < len(ui.elements), i++ {
                elem = _uiElementRecusriveCollideFiltered(ui.elements[i], pos, __ui_filterIsElemScrollable)
                if elem != null {
                    elem.offsets[1] += 10
                    size = elem.getSize()
                    innerSize = elem.getInnerSize()
                    if elem.offsets[1] + size[1] > innerSize[1] {
                        elem.offsets[1] = innerSize[1] - size[1]
                    }
                    __uiRedrawElement(ui, elem)
                    break
                }
            }
        } else if clickedBtn == MOUSE_SCROLL_UP {
            i=0; for i < len(ui.elements), i++ {
                elem = _uiElementRecusriveCollideFiltered(ui.elements[i], pos, __ui_filterIsElemScrollable)
                if elem != null {
                    elem.offsets[1] -= 10
                    if elem.offsets[1] < 0 {
                        elem.offsets[1] = 0
                    }
                    __uiRedrawElement(ui, elem)
                    break
                }
            }
        }
    } else if event == windowEventMouseUp {
        pos = ui.getCursorPosition()
        clickedBtn = ui.getEventButton()
        if clickedBtn == MOUSE_LEFT_BUTTON {
            if ui.focusedElement != null {
                i=0; for i < len(ui.elements), i++ {
                    elem = _uiElementRecusriveCollide(ui.elements[i], pos)
                    if elem != null {
                        if elem != ui.focusedElement {
                            ui.focusedElement.clicked = false
                            __uiRedrawElement(ui, ui.focusedElement)
                            ui.focusedElement.focused = false
                            __uiDispatchEvent(ui, ui.focusedElement, uiEventElementFocusOut)
                            ui.focusedElement = null
                        } else {
                            elem.clicked = false
                            __uiDispatchEvent(ui, elem, uiEventElementClicked)
                            break
                        }
                    }
                }
                if i == len(ui.elements) && ui.focusedElement != null {
                    ui.focusedElement.clicked = false
                    __uiRedrawElement(ui, ui.focusedElement)
                    ui.focusedElement.focused = false
                    __uiDispatchEvent(ui, ui.focusedElement, uiEventElementFocusOut)
                    ui.focusedElement = null
                }
            }
        }
    }

    if ui.needsRedraw {
        ui.redraw()
        ui.needsRedraw = false
    }
    ui.animationsMutex.unlock()
}