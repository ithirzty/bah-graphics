#import "time.bah"

#import "./graphics.bah"

const uiEventElementAdded           = 1024
const uiEventElementHoverIn         = 1025
const uiEventElementHoverOut        = 1026
const uiEventElementClicked         = 1027
const uiEventElementFocusIn         = 1028
const uiEventElementFocusOut        = 1029
const uiEventElementHovered         = 1030
const uiEventElementMouseDown       = 1031
const uiEventElementFileDrag        = 1032
const uiEventElementFileDrop        = 1033
const uiEventElementFileDropOutside = 1034

const uiNotDrawnEvents = []uint{
    uiEventElementHovered
}

#import "./elements/base.bah"

#define usleep(us uint)

#define __uiHandleEvents(ui window*, event uint32)
#define __uiSetElementOnFocus(ui window*, elem uiElement*)
#define __uiAnimationHandler(ui window*)

struct uiAnimation {
    time: uint
    freq: uint
    duration: uint
    elem: uiElement*
    processed: bool
}

struct uiBorderlessWindow extend window {
    font: font
    parent: window*
    lastEvent: xcb_generic_event_t*

    launch(x uint, y uint, width uint, height uint) {
        this.haveFrame.init()
        this.haveFrameMut.init()

        this.isRunning = true

        threadWrkrFn = this.__drawThreadworker

        i=1; for i <= __graphicsNbDrawers, i++ {
            async threadWrkrFn(this, i)

        }

        this.width = width
        this.height = height
        screen_number = <int32>0
        this.connection = xcb_connect(null, &screen_number);
        if (xcb_connection_has_error(this.connection)) {
            xcb_disconnect(this.connection)
            return
        }

        setup = xcb_get_setup(this.connection)
        iter = xcb_setup_roots_iterator(setup)

        i=0; for i < screen_number, i++ {
            xcb_screen_next(&iter)
        }

        this.screen = iter.data

        this.window = xcb_generate_id(this.connection)
        value_mask = XCB_CW_OVERRIDE_REDIRECT | XCB_CW_EVENT_MASK

        value_list = [
            <uint32>1,
            XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_KEY_PRESS | XCB_EVENT_MASK_KEY_RELEASE | XCB_EVENT_MASK_BUTTON_PRESS | XCB_EVENT_MASK_BUTTON_RELEASE | XCB_EVENT_MASK_POINTER_MOTION | XCB_EVENT_MASK_BUTTON_MOTION | XCB_EVENT_MASK_FOCUS_CHANGE | XCB_EVENT_MASK_STRUCTURE_NOTIFY
        ]

        xcb_create_window(
            this.connection,
            0,          // profondeur (default)
            this.window,                        // ID de la fenêtre
            this.screen.root,                  // fenêtre parente
            x, y, width, height,                // position et taille
            0,
            XCB_WINDOW_CLASS_INPUT_OUTPUT, // type
            this.screen.root_visual,           // visual
            value_mask, &value_list
        )

        xcb_map_window(this.connection, this.window)
        xcb_flush(this.connection)

        size = width * height * 4

        shmid = shmget(0, size, 896)

        if shmid < 0 {
            panic("erorr allocating shared memory")
        }

        this.frameBuffer = shmat(shmid, null, 0)

        shminfo = xcb_shm_segment_info_t {
            shmseg: xcb_generate_id(this.connection)
            shmid: shmid
            shmaddr: this.frameBuffer
        }

        xcb_shm_attach(this.connection, shminfo.shmseg, shminfo.shmid, 0);
        xcb_flush(this.connection)

        this.keySyms = xcb_key_symbols_alloc(this.connection)

        xcb_cursor_context_new(this.connection, this.screen, &this.cursorCtx)

        event xcb_generic_event_t*

        gc = xcb_generate_id(this.connection)
        values = [0]
        xcb_create_gc(this.connection, gc, this.window, XCB_GC_GRAPHICS_EXPOSURES, &values)

        xdnd_version = 5

        xcb_change_property(this.connection,
            XCB_PROP_MODE_REPLACE,
            this.window,
            xcb_getAtom(this.connection, "XdndAware"),
            XCB_ATOM_CARDINAL,
            32,
            1,
            &xdnd_version)

        this.isExposed = false
        for true, event = xcb_wait_for_event(this.connection) {
            if event == null {
                if this.isExposed {
                    this.callEventFunction(windowEventClose)
                    break
                }
                continue
            }

            eventType = event.response_type & 0x7F

            if eventType == 22 {
                cfg = <xcb_configure_notify_event_t *>event
                if cfg.width == this.width && cfg.height == this.height {
                    continue
                }
                this.width  = cfg.width
                this.height = cfg.height

                xcb_shm_detach(this.connection, shminfo.shmseg)
                shmdt(this.frameBuffer)
                shmctl(shminfo.shmid, 0, null)

                // nouvelle taille
                size = this.width * this.height * 4;
                shminfo.shmid = shmget(0, size, 896)
                this.frameBuffer = shmat(shminfo.shmid, null, 0)
                shminfo.shmseg = xcb_generate_id(this.connection)

                // nouveau segment
                xcb_shm_attach(this.connection, shminfo.shmseg, shminfo.shmid, 0)
                this.callEventFunction(windowEventDraw)
            } else if eventType == 12 {
                if this.isExposed == false {
                    this.callEventFunction(windowEventInitialize)
                    this.isExposed = true
                }

                this.hasDrawn = false
                this.callEventFunction(windowEventDraw)

                xcb_shm_put_image(
                    this.connection,
                    this.window,
                    gc,
                    this.width, this.height,
                    0, 0, this.width, this.height,
                    0, 0,
                    this.screen.root_depth,
                    XCB_IMAGE_FORMAT_Z_PIXMAP,
                    0,
                    shminfo.shmseg,
                    0
                )

                xcb_flush(this.connection)
                c = xcb_get_input_focus(this.connection)
                xcb_get_input_focus_reply(this.connection, c, null)
            } else if eventType == 6 {
                this.callEventFunction(windowEventMouseMove)
            } else if eventType == 4 {
                this.lastMouseCode = event.pad0
                this.callEventFunction(windowEventMouseDown)
            } else if eventType == 5 {
                this.lastMouseCode = event.pad0
                this.callEventFunction(windowEventMouseUp)
            } else if eventType == 2 {
                this.lastKeyCode = event.pad0

                if event.pad0 == 37 || event.pad0 == 105 {
                    this.keyModifiers = this.keyModifiers | 0x01 //ctrl
                } else if event.pad0 == 50 || event.pad0 == 62 {
                    this.keyModifiers = this.keyModifiers | 0x02 //shift
                } else if event.pad0 == 64 {
                    this.keyModifiers = this.keyModifiers | 0x04 //alt
                } else if event.pad0 == 108 {
                    this.keyModifiers = this.keyModifiers | 0x08 //altgr
                } else if event.pad0 == 66 {
                    this.shiftLock = this.shiftLock == false
                }
                this.callEventFunction(windowEventKeyDown)
            } else if eventType == 3 {
                this.lastKeyCode = event.pad0

                if event.pad0 == 37 || event.pad0 == 105 {
                    this.keyModifiers = this.keyModifiers & ~0x01
                } else if event.pad0 == 50 || event.pad0 == 62 {
                    this.keyModifiers = this.keyModifiers & ~0x02
                } else if event.pad0 == 64 {
                    this.keyModifiers = this.keyModifiers & ~0x04
                } else if event.pad0 == 108 {
                    this.keyModifiers = this.keyModifiers & ~0x08
                }
                this.callEventFunction(windowEventKeyUp)
            } else if eventType == 33 && ((<xcb_client_message_event_t*>event).type) == 68 {
                free(event)
                break
            } else {
                this.lastEvent = event
                this.callEventFunction(1024)
            }

            free(event)
        }

        this.isRunning = false
        this.haveFrame.broadcast()

        xcb_cursor_context_free(this.cursorCtx)
        xcb_shm_detach(this.connection, shminfo.shmseg)
        shmdt(this.frameBuffer)
        shmctl(shmid, 0, null)
        xcb_key_symbols_free(this.keySyms)
        xcb_disconnect(this.connection)

        this.haveFrame.destroy()
        this.haveFrameMut.destroy()

        this.parent.redraw()
    }
}

struct contextMenuWindow extend uiBorderlessWindow {
    list: []uiContextItem
    choice: int = -1
    elem: uiElement*
}

struct fileDragWindow extend uiBorderlessWindow {
    offsets: [int,int]
    elem: uiElement*
    image: []rgbColor
    fileUri: str
    oldTarget: int = -1
}

struct ui extend window {
    font: font
    elements: []uiElement*
    focusedElement: uiElement*

    animations: []uiAnimation
    animationsMutex: mutex
    animationsCond: mutexCondition

    frameStart: uint
    isDrawing: bool

    alreadyDrawn: bool
    needsRedraw: bool
    isPartialRedraw: bool
    draggingStage: byte

    _oldDimensions: [int,int]

    ctxWindow: contextMenuWindow*
    fileDragWindow: fileDragWindow*

    _init() {
        this.font = getSystemUIfont()
        this.events = __uiHandleEvents
        this.animationsMutex.init()
        this.animationsCond.init()
    }

    addElement(elem uiElement*) {
        elem.window = this
        this.elements[len(this.elements)] = elem

        __uiConstructElementTreeRecursively(elem)

        if this.isExposed {
            if this.isDrawing == false {
                this.frameStart = getTimeUnix()
            }
            this.redraw()
        }
    }

    setFocus(elem uiElement*) {
        __uiSetElementOnFocus(this, elem)
    }

    find(id str) uiElement* {
        i=0; for i < len(this.elements), i++ {
            f = this.elements[i].find(id)
            if f != null {
                return f
            }
        }
        
        return null
    }

    launch(width uint, height uint, title str) {
        this.ctxWindow = new contextMenuWindow {
            parent: this
            font: getSystemUIfont()
            events: function(win contextMenuWindow*, event uint32) {
                ui = <ui*>win.parent

                if event == windowEventMouseMove {
                    win.redraw()
                } else if event == windowEventDraw || event == windowEventInitialize {
                    win.clear(BLACK)
                    win.setCursor("hand1")
                    win.font.setSize(8)

                    cursorPos = win.getCursorPosition()

                    i=0; for i < len(win.list), i++ {
                        pos = [1, i * 31 + 1]

                        bgColor = WHITE
                        fgColor = BLACK

                        if win.choice == i {
                            fgColor = WHITE
                            bgColor = rgbColor{120, 120, 255}
                        } else if cursorPos[1] >= pos[1] && cursorPos[1] < pos[1] + 30 {
                            bgColor = rgbColor{191, 191, 255}
                        }
                        win.drawRect(pos, [win.width - 2, 30], bgColor)

                        win.drawText(win.font, win.list[i].name, fgColor, [pos[0] + 4, pos[1] + 20])
                        offset = 52

                        if win.list[i].shift {
                            offset += 36
                        }

                        if win.list[i].alt {
                            offset += 25
                        }

                        cPos = [win.width - offset, pos[1] + 20]

                        if win.list[i].ctrl {
                            cPos = win.drawText(win.font, "CTRL", rgbColor{80, 80, 80}, [cPos[0], pos[1] + 20])
                            cPos = win.drawChar(win.font, '+', rgbColor{80, 80, 80}, [cPos[0], pos[1] + 20])
                        }
                        if win.list[i].shift {
                            cPos = win.drawText(win.font, "SHIFT", rgbColor{80, 80, 80}, [cPos[0], pos[1] + 20])
                            cPos = win.drawChar(win.font, '+', rgbColor{80, 80, 80}, [cPos[0], pos[1] + 20])
                        }
                        if win.list[i].key < 65000 {
                            win.drawChar(win.font, win.list[i].key, rgbColor{80, 80, 80}, [cPos[0], pos[1] + 20])
                        }
                    }
                } else if event == windowEventMouseDown {
                    cursorPos = win.getCursorPosition()
                    i=0; for i < len(win.list), i++ {
                        pos = [0, i * 31 + 1]

                        if cursorPos[1] >= pos[1] && cursorPos[1] < pos[1] + 30 {
                            win.choice = i
                            // cb = win.list[i].callback
                            // cb(&win.list[i], win.elem)
                            break
                        }
                    }
                    win.redraw()
                } else if event == windowEventMouseUp {
                    cursorPos = win.getCursorPosition()
                    i=0; for i < len(win.list), i++ {
                        pos = [0, i * 31 + 1]

                        if cursorPos[1] >= pos[1] && cursorPos[1] < pos[1] + 30 {
                            break
                        }
                    }
                    if i == win.choice {
                        win.close()
                    } else {
                        win.choice = -1
                        win.redraw()
                    }
                }
            }
        }
        win = <window*>this
        win.launch(width, height, title)
    }
}

// __uiPropagateUpdateElementMask(ui ui*, currElem uiElement*) {
//     i=0; for i < len(currElem.elements), i++ {
//         pos = currElem.elements[i].getPosition()
//         size = currElem.elements[i].getSize()
//         if currElem.elements[i].manualDrawingMode == false {
//             ui.getRect(pos, size, currElem.elements[i].maskedBuffer)
//         }
//     }
// }

_uiDrawElementBackground(pos [int,int], size [int,int], currElem uiElement*) {
    ui = <ui*>currElem.window

    os = ui.scissor

    ui.setScissor(pos, size)

    if os[0] {
        if os[1] > ui.scissor[1] {
            ui.scissor[1] = os[1]
        }

        if os[2] > ui.scissor[2] {
            ui.scissor[2] = os[2]
        }

        if os[3] < ui.scissor[3] {
            ui.scissor[3] = os[3]
        }

        if os[4] < ui.scissor[4] {
            ui.scissor[4] = os[4]
        }
    }

    if currElem.parent != null {
        i=0; for i < len(currElem.parent.elements), i++ {
            if currElem.parent.elements[i] == currElem {
                break
            }
        }
        __uiRedrawElement(ui, currElem.parent, __uiElementDrawTypeBackground + i)
    } else {
        ui.clear(WHITE)
    }

    ui.scissor = os

}

__uiIsOutsideScissor(ui ui*, pos [int,int], size [int,int]) bool {
    max = [pos[0] + size[0], pos[1] + size[1]]

    if max[0] < ui.scissor[1] || max[1] < ui.scissor[2] {
        return true
    }

    if pos[0] > ui.scissor[3] || pos[1] > ui.scissor[4] {
        return true
    }

    return false
}

__uiRedrawElement(ui ui*, elem uiElement*, drawType int) {
    if ui.isDrawing == false {
        ui.frameStart = getTimeUnix()
        ui.isDrawing = true
    }
    ui.needsRedraw = true
    currElem = elem
    for currElem != null, currElem = currElem.parent {

        if currElem.toRemove {
            return
        }

        if currElem.hashChanged() {
            if currElem.parent == null {
                currElem = null
                break
            }

            if drawType == __uiElementDrawTypeFull {
                __uiRedrawElement(ui, currElem.parent, __uiElementDrawTypeFull)
                return
            }
        }
        ui.alreadyDrawn = true
        drawFn = currElem._draw
        if drawFn != null {

            pos = currElem.getPosition()
            size = currElem.getSize()
            if ui.scissor[0] && __uiIsOutsideScissor(ui, pos, size) {
                return
            }

            currBox = currElem
            //Checking recursively if there is an element on top. If it is the case,
            //redraw their common parent entirely.
            for currBox != null, currBox = currBox.parent {
                if drawType == __uiElementDrawTypeFull && currBox.parent != null {
                    i=0; for i < len(currBox.parent.elements), i++ {
                        if currBox.parent.elements[i] == currBox {
                            i++
                            break
                        }

                        if currBox.parent.elements[i].absolutePosition {
                            nextElem = currBox.parent.elements[i]
                            nextPos = nextElem.getPosition()
                            nextMax = nextElem.getSize()
                            nextMax[0] += nextPos[0]
                            nextMax[1] += nextPos[1]
                            if nextPos[0] < pos[0] + size[0] && nextPos[1] < pos[1] + size[1] && nextMax[0] > pos[0] && nextMax[1] > pos[1] {
                                __uiRedrawElement(ui, currBox.parent, __uiElementDrawTypeFull)
                                return
                            }
                        }
                    }

                    for i < len(currBox.parent.elements), i++ {
                        nextElem = currBox.parent.elements[i]
                        nextPos = nextElem.getPosition()
                        nextMax = nextElem.getSize()
                        nextMax[0] += nextPos[0]
                        nextMax[1] += nextPos[1]
                        if nextPos[0] < pos[0] + size[0] && nextPos[1] < pos[1] + size[1] && nextMax[0] > pos[0] && nextMax[1] > pos[1] {
                            __uiRedrawElement(ui, currBox.parent, __uiElementDrawTypeFull)
                            return
                        }
                    }
                }
            }

            os = ui.scissor
            if drawType < __uiElementDrawTypeBackground {
                if elem.parent != null {
                    scissor = [0,0,0,0]

                    currBox = elem.parent
                    for currBox != null, currBox = currBox.parent {
                        bSize = currBox.getSize()
                        bPos = currBox.getPosition()

                        if currElem.absolutePosition == false {
                            bPos[0] += currBox.innerMargin[0]
                            bPos[1] += currBox.innerMargin[1]
                            bSize[0] -= (currBox.innerMargin[0] + currBox.innerMargin[2])
                            bSize[1] -= (currBox.innerMargin[1] + currBox.innerMargin[3])
                        }

                        if scissor[2] + scissor[3] == 0 {
                            scissor[0] = bPos[0]
                            scissor[1] = bPos[1]
                            scissor[2] = bPos[0] + bSize[0]
                            scissor[3] = bPos[1] + bSize[1]
                            continue
                        }

                        if bPos[0] > scissor[0] {
                            scissor[0] = bPos[0]
                        }

                        if bPos[1] > scissor[1] {
                            scissor[1] = bPos[1]
                        }

                        if bPos[0] + bSize[0] < scissor[2] {
                            scissor[2] = bPos[0] + bSize[0]
                        }

                        if bPos[1] + bSize[1] < scissor[3] {
                            scissor[3] = bPos[1] + bSize[1]
                        }
                    }

                    ui.setScissor([scissor[0], scissor[1]], [scissor[2] - scissor[0], scissor[3] - scissor[1]])
                } else {
                    ui.disableScissor()
                }
            }

            if currElem.manualDrawingMode == false && drawType != __uiElementDrawTypeChildren {
                if ui.scissor[0] != false {
                    if pos[0] < ui.scissor[1] {
                        size[0] -= ui.scissor[1] - pos[0]
                        pos[0] = ui.scissor[1]
                    }
                    if pos[1] < ui.scissor[2] {
                        size[1] -= ui.scissor[2] - pos[1]
                        pos[1] = ui.scissor[2]
                    }
                }
                _uiDrawElementBackground(pos, size, currElem)
            }

            drawFn(currElem, ui)


            max = len(currElem.elements)
            if drawType >= __uiElementDrawTypeBackground {
                max = drawType - __uiElementDrawTypeBackground
                i=0; for i < max, i++ {
                    el = currElem.elements[i]
                    __uiRedrawElement(ui, el, __uiElementDrawTypeBackground + len(el.elements))
                }
            } else {
                i=0; for i < max, i++ {
                    el = currElem.elements[i]
                    __uiRedrawElement(ui, el, __uiElementDrawTypeChildren)
                }
            }
            ui.scissor = os
            break
        }
    }

    if currElem == null {
        ui.alreadyDrawn = false
    }

}

__uiRedrawElementDelayed(ui ui*, elem uiElement*, ms uint) {
    now = getTimeUnix() / 1000000
    i=0; for i < len(ui.animations), i++ {
        anim = &ui.animations[i]
        if anim.elem == elem && anim.processed == false {
            anim.freq = ms
            return
        }
    }

    ui.animations[len(ui.animations)] = uiAnimation {
        time: now
        freq: ms
        elem: elem
    }

    ui.animationsCond.send()
}

__uiAnimationHandler(ui ui*) {
    freq = 40
    for ui.isRunning {
        ui.animationsMutex.lock()
        // println("waiting: "+uintToStr(freq)+"ms")
        if len(ui.animations) == 0 {
            ui.animationsCond.wait(ui.animationsMutex)
        } else {
            ui.animationsMutex.unlock()
            usleep(freq * 1000)
            ui.animationsMutex.lock()
        }
        


        if ui.needsRedraw {
            ui.animationsMutex.unlock()
            continue
        }

        now = getTimeUnix() / 1000000
        freq = 40
        found = false
        i=len(ui.animations) - 1; for i != -1, i-- {
            anim = &ui.animations[i]
            if anim.freq < 250 && (anim.freq < freq || i == len(ui.animations) - 1) {
                freq = anim.freq
            }
            
            if <int>(anim.freq + anim.time) - now <= 30 && anim.processed == false {
                anim.processed = true
                found = true
                break
            }
        }

        if found {
            ui.isPartialRedraw = true
            ui.redraw()
        }
        ui.animationsMutex.unlock()
    }
    ui.animationsMutex.destroy()
    ui.animationsCond.destroy()

}

__uiDispatchEvent(ui ui*, elem uiElement*, event uint32) {
    if event == windowEventKeyDown {
        i=0; for i < len(elem.contextItems), i++ {
            ci = &elem.contextItems[i]
            if ci.ctrl != ui.isKeyModifier(Key_CTRL) || ci.shift != ui.isKeyModifier(Key_SHIFT) || ci.alt != ui.isKeyModifier(Key_ALT) {
                continue
            }

            if ci.key == ui.getEventChar() && ci.callback != null {
                ci.callback(elem)
                break
            }
        }
    } else if event == uiEventElementMouseDown && ui.getEventButton() == MOUSE_RIGHT_BUTTON && len(elem.contextItems) != 0 {
        curs = ui.toScreenCoord(ui.getCursorPosition())
        ui.ctxWindow.list = elem.contextItems
        ui.ctxWindow.elem = elem
        ui.ctxWindow.font.setSize(8)

        maxWidth = 0

        i=0; for i < len(elem.contextItems), i++ {
            size = ui.ctxWindow.measureText(ui.ctxWindow.font, elem.contextItems[i].name)[0] + 40

            if elem.contextItems[i].ctrl {
                size += 32
            }

            if elem.contextItems[i].shift {
                size += 36
            }

            if elem.contextItems[i].alt {
                size += 25
            }

            if size > maxWidth {
                maxWidth = size
            }
        }

        async ui.ctxWindow.launch(curs[0], curs[1], maxWidth + 2, len(elem.contextItems) * 31 + 1)
    }

    if elem._events != null {
        elem._events(event)
    }

    // if elem.manualDrawingMode == false {
    if event in uiNotDrawnEvents == false {
        __uiRedrawElement(ui, elem, __uiElementDrawTypeFull)
    }
    // }
}

_uiElementRecusriveRemove(elem uiElement*, ui ui*, forceRemove bool) bool {
    toRemove = forceRemove || elem.toRemove
    hasRemoved = false
    i=0; for i < len(elem.elements), i++ {
        if _uiElementRecusriveRemove(elem.elements[i], ui, toRemove) {
            if forceRemove == false {

                if elem.elements[i].hashChanged() == false && elem.elements[i].manualDrawingMode == false {
                    pos = elem.elements[i].getPosition()
                    size = elem.elements[i].getSize()
                    _uiDrawElementBackground(pos, size, elem.elements[i])
                } else {
                    hasRemoved = true
                }

                j=len(ui.animations) - 1; for j != -1, j-- {
                    anim = &ui.animations[j]
                    if anim.elem == elem.elements[i] {
                        delete(ui.animations, j)
                    }
                }

                if ui.focusedElement == elem.elements[i] {
                    ui.focusedElement = null
                }
                delete(elem.elements, i)
                i--
            }
        }
    }

    if hasRemoved && toRemove == false {
        __uiRedrawElement(ui, elem, __uiElementDrawTypeFull)
    }

    return toRemove
}

_uiElementRecusriveResetHover(elem uiElement*, ui ui*) {
    wasHovered = elem.hovered
    elem.hovered = false
    if wasHovered {
        __uiRedrawElement(ui, elem, __uiElementDrawTypeFull)
        __uiDispatchEvent(ui, elem, uiEventElementHoverOut)
    }
    
    i=0; for i < len(elem.elements), i++ {
        _uiElementRecusriveResetHover(elem.elements[i], ui)
    }
}

_uiElementRecusriveHover(elem uiElement*, ui ui*, pos [int,int]) [uiElement*, uint, bool] {
    elemPos = elem.getPosition()
    elemSize = elem.getSize()
    cursorChanged = false
    nb = 0
    if pos[0] >= elemPos[0] && pos[0] < elemPos[0] + elemSize[0] {
        if pos[1] >= elemPos[1] && pos[1] < elemPos[1] + elemSize[1] {
            wasHovered = elem.hovered
            elem.hovered = true
            nb++
            i=0; for i < len(elem.elements), i++ {
                childCons = _uiElementRecusriveHover(elem.elements[i], ui, pos)
                nb += childCons[1]
                if childCons[2] {
                    cursorChanged = true
                }
                if childCons[0] != null {
                    if len(childCons[0].cursor) != 0 {
                        ui.setCursor(childCons[0].cursor)
                        cursorChanged = true
                    }
                    __uiDispatchEvent(ui, childCons[0], uiEventElementHoverIn)
                }
            }

            if wasHovered {
                __uiDispatchEvent(ui, elem, uiEventElementHovered)
                if len(elem.cursor) != 0 {
                    cursorChanged = true
                }

                return [null, nb, cursorChanged]
            }

            if len(elem.cursor) != 0 {
                ui.setCursor(elem.cursor)
                cursorChanged = true
            }
            __uiDispatchEvent(ui, elem, uiEventElementHoverIn)

            return [elem, nb, cursorChanged]
        }
    }
    _uiElementRecusriveResetHover(elem, ui)
    return [null, nb, false]
}

_uiElementRecusriveCollide(elem uiElement*, pos [int,int]) uiElement* {
    elemPos = elem.getPosition()
    elemSize = elem.getSize()
    if pos[0] >= elemPos[0] && pos[0] < elemPos[0] + elemSize[0] {
        if pos[1] >= elemPos[1] && pos[1] < elemPos[1] + elemSize[1] {
            i=len(elem.elements) - 1; for i != -1, i-- {
                ce = _uiElementRecusriveCollide(elem.elements[i], pos)
                if ce != null && ce.focusable {
                    return ce
                }
            }

            if elem.focusable {
                return elem
            }
        }
    }
    return null
}

__ui_filterIsElemScrollableV(elem uiElement*) bool {
    size = elem.getSize()
    
    innerSize = elem.getInnerSize()

    return innerSize[1] > size[1]
}

__ui_filterIsElemScrollableH(elem uiElement*) bool {
    size = elem.getSize()
    
    innerSize = elem.getInnerSize()

    return innerSize[0] > size[0]
}

__ui_filterIsElemDragTarget(elem uiElement*) bool {
    return elem.dragTarget && elem.focusable
}

_uiElementRecusriveCollideFiltered(elem uiElement*, pos [int,int], filter function(uiElement*) bool) uiElement* {
    elemPos = elem.getPosition()
    elemSize = elem.getSize()
    if pos[0] >= elemPos[0] && pos[0] < elemPos[0] + elemSize[0] {
        if pos[1] >= elemPos[1] && pos[1] < elemPos[1] + elemSize[1] {
            i=len(elem.elements) - 1; for i != -1, i-- {
                ce = _uiElementRecusriveCollideFiltered(elem.elements[i], pos, filter)
                if ce != null && filter(ce) {
                    return ce
                }
            }
            if filter(elem) {
                return elem
            }
        }
    }
    return null
}

__uiSetElementOnFocus(ui ui*, elem uiElement*) {
    if ui.focusedElement != null {
        if elem == ui.focusedElement {
            return
        }

        ui.focusedElement.clicked = false
        __uiRedrawElement(ui, ui.focusedElement, __uiElementDrawTypeFull)
        ui.focusedElement.focused = false
        __uiDispatchEvent(ui, ui.focusedElement, uiEventElementFocusOut)
        ui.focusedElement = null
    }
    if elem != null {
        ui.focusedElement = elem
        ui.focusedElement.focused = true
        __uiDispatchEvent(ui, ui.focusedElement, uiEventElementFocusIn)
        elem.clicked = true
        __uiRedrawElement(ui, elem, __uiElementDrawTypeFull)
    }
}

__uiForceDrawElement(ui ui*, elem uiElement*) {
    fn = elem._draw
    if fn != null {
        os = ui.scissor
        if elem.parent != null {
            scissor = [0,0,0,0]

            currBox = elem.parent
            for currBox != null, currBox = currBox.parent {
                bSize = currBox.getSize()
                bPos = currBox.getPosition()

                if elem.absolutePosition == false {
                    bPos[0] += currBox.innerMargin[0]
                    bPos[1] += currBox.innerMargin[1]
                    bSize[0] -= (currBox.innerMargin[0] + currBox.innerMargin[2])
                    bSize[1] -= (currBox.innerMargin[1] + currBox.innerMargin[3])
                }

                if scissor[2] + scissor[3] == 0 {
                    scissor[0] = bPos[0]
                    scissor[1] = bPos[1]
                    scissor[2] = bPos[0] + bSize[0]
                    scissor[3] = bPos[1] + bSize[1]
                    continue
                }

                if bPos[0] > scissor[0] {
                    scissor[0] = bPos[0]
                }

                if bPos[1] > scissor[1] {
                    scissor[1] = bPos[1]
                }

                if bPos[0] + bSize[0] < scissor[2] {
                    scissor[2] = bPos[0] + bSize[0]
                }

                if bPos[1] + bSize[1] < scissor[3] {
                    scissor[3] = bPos[1] + bSize[1]
                }
            }

            ui.setScissor([scissor[0], scissor[1]], [scissor[2] - scissor[0], scissor[3] - scissor[1]])
        } else {
            ui.disableScissor()
        }
        
        fn(elem, ui)
        elem.hashChanged()
        ui.scissor = os
    }

    i=0; for i < len(elem.elements), i++ {
        __uiForceDrawElement(ui, elem.elements[i])
    }
}
__uiStartFileDrag(ui ui*, uri str, elem uiElement*) {
    curs = ui.getCursorPosition()
    screenPosCurs = ui.toScreenCoord(curs)
    pos = elem.getPosition()

    os = ui.scissor
    scissor = [0,0,0,0]

    currBox = elem
    for currBox != null, currBox = currBox.parent {
        bSize = currBox.getSize()
        bPos = currBox.getPosition()

        if elem.absolutePosition == false {
            bPos[0] += currBox.innerMargin[0]
            bPos[1] += currBox.innerMargin[1]
            bSize[0] -= (currBox.innerMargin[0] + currBox.innerMargin[2])
            bSize[1] -= (currBox.innerMargin[1] + currBox.innerMargin[3])
        }

        if scissor[2] + scissor[3] == 0 {
            scissor[0] = bPos[0]
            scissor[1] = bPos[1]
            scissor[2] = bPos[0] + bSize[0]
            scissor[3] = bPos[1] + bSize[1]
            continue
        }

        if bPos[0] > scissor[0] {
            scissor[0] = bPos[0]
        }

        if bPos[1] > scissor[1] {
            scissor[1] = bPos[1]
        }

        if bPos[0] + bSize[0] < scissor[2] {
            scissor[2] = bPos[0] + bSize[0]
        }

        if bPos[1] + bSize[1] < scissor[3] {
            scissor[3] = bPos[1] + bSize[1]
        }
    }

    ui.setScissor([scissor[0], scissor[1]], [scissor[2] - scissor[0], scissor[3] - scissor[1]])
    
    ui.clear(BLACK)
    __uiForceDrawElement(ui, elem)

    for atomic_load(&ui.frameDone) == 0 {
        sched_yield()
    }

    imgBuf = []rgbColor
    ui.getRect([ui.scissor[1], ui.scissor[2]], [ui.scissor[3] - ui.scissor[1], ui.scissor[4] - ui.scissor[2]], imgBuf)
    ui.scissor = os

    bdlWindow = new fileDragWindow {
        parent: ui
        image: imgBuf
        elem: elem
        offsets: [
            curs[0] - scissor[0],
            curs[1] - scissor[1]
        ]
    }
    

    bdlWindow.events = function(w fileDragWindow*, event uint32) {
        if event == windowEventInitialize {
            w.setOpacity(0.8)

            xcb_shape_mask(w.connection, XCB_SHAPE_SO_SET, 2, w.window, 0, 0, 0)
            xcb_flush(w.connection)
        } else if event == windowEventDraw {
            w.drawRectImage([0, 0], [w.width, w.height], w.image)
            for atomic_load(&w.frameDone) == 0 {
                sched_yield()
            }
        }
    }

    ui.fileDragWindow = bdlWindow
    
    async bdlWindow.launch(screenPosCurs[0] - bdlWindow.offsets[0], screenPosCurs[1] - bdlWindow.offsets[1], elem.size[0], elem.size[1])

}

__uiHandleEvents(ui ui*, event uint32) {
    ui.animationsMutex.lock()

    if ui.ctxWindow.isRunning && (event == windowEventClose || event == windowEventMouseDown || event == windowEventKeyDown || event == windowEventFocusOut || event == windowEventResize) {
        ui.ctxWindow.close()
    } else if ui.ctxWindow.choice != -1 && ui.ctxWindow.isRunning == false {
        cb = ui.ctxWindow.list[ui.ctxWindow.choice].callback
        cb(&ui.ctxWindow.list[ui.ctxWindow.choice], ui.ctxWindow.elem)
        __uiRedrawElement(ui, ui.ctxWindow.elem, __uiElementDrawTypeFull)
        ui.ctxWindow.choice = -1
    }

    if event == windowEventInitialize || event == windowEventDraw {
        if event == windowEventInitialize {
            ui.alreadyDrawn = false
            async __uiAnimationHandler(ui)
        }

        if ui.width != ui._oldDimensions[0] {
            ui._oldDimensions[0] = ui.width
            ui.alreadyDrawn = false
        }

        if ui.height != ui._oldDimensions[1] {
            ui._oldDimensions[1] = ui.height
            ui.alreadyDrawn = false
        }


        i=0; for i < len(ui.elements), i++ {
            if ui.elements[i].toRemove {
                _uiElementRecusriveRemove(ui.elements[i], ui, true)
                if ui.elements[i].hashChanged() == false && ui.elements[i].manualDrawingMode == false {
                    pos = ui.elements[i].getPosition()
                    size = ui.elements[i].getSize()
                    _uiDrawElementBackground(pos, size, ui.elements[i])
                } else {
                    ui.alreadyDrawn = false
                }
                j=len(ui.animations) - 1; for j != -1, j-- {
                    anim = &ui.animations[j]
                    if anim.elem == ui.elements[i] {
                        delete(ui.animations, j)
                    }
                }
                delete(ui.elements, i)
                //remove its animations
                //instead of full redraw, paint its bg mask
                i--
            } else {
                _uiElementRecusriveRemove(ui.elements[i], ui, false)
            }
        }


        onrd = ui.needsRedraw
        i=len(ui.animations) - 1; for i != -1, i-- {
            anim = &ui.animations[i]
            
            if anim.processed {
                absTime = anim.freq / 1000 + anim.time
                __uiRedrawElement(ui, anim.elem, __uiElementDrawTypeFull)
                delete(ui.animations, i)
            }
        }
        ui.needsRedraw = onrd

        if ui.alreadyDrawn == false && ui.isPartialRedraw == false {
            if ui.isDrawing == false {
                ui.frameStart = getTimeUnix()
                ui.isDrawing = true
            }
            ui.clear(WHITE)
            i=0; for i < len(ui.elements), i++ {
                __uiForceDrawElement(ui, ui.elements[i])
            }
        }
        
        #debug {
            if ui.isDrawing {
                ui.isDrawing = false
                totalTime = (getTimeUnix() - ui.frameStart)
                ms = totalTime / 1000000
                fps = 1000000000 / totalTime
                print("\rframe:\t"+intToStr(ms)+"ms  \t"+intToStr(fps)+"fps   ")

            }
        }
        ui.isPartialRedraw = false
    }

    if event == windowEventKeyDown || event == windowEventKeyUp {
        if ui.focusedElement != null {
            __uiDispatchEvent(ui, ui.focusedElement, event)
        }
    } else if event == windowEventMouseMove {
        pos = ui.getCursorPosition()

        if ui.draggingStage == 1 {
            ui.draggingStage = 2
            i=0; for i < len(ui.elements), i++ {
                elem = _uiElementRecusriveCollide(ui.elements[i], pos)
                if elem != null {
                    __uiSetElementOnFocus(ui, elem)
                    if len(elem.fileURI) != 0 {
                        clear(ui.tmpFilesDragged)
                        ui.tmpFilesDragged[0] = elem.fileURI
                        ui.setCursor("grabbing")
                        __uiStartFileDrag(ui, elem.fileURI, elem)

                        xcb_set_selection_owner(
                            ui.connection,
                            ui.window,
                            ui.atoms.XdndSelection,
                            0
                        )

                        typesList = [ui.atoms.text_uri_list, ui.atoms.text_x_moz_url]

                        xcb_change_property(
                            ui.connection,
                            XCB_PROP_MODE_REPLACE,
                            ui.window,
                            ui.atoms.XdndTypeList,
                            XCB_ATOM_ATOM,
                            32,
                            2,
                            &typesList
                        )

                        actions = [
                            ui.atoms.XdndActionCopy,
                            ui.atoms.XdndActionMove
                        ]
                        

                        xcb_change_property(
                            ui.connection,
                            XCB_PROP_MODE_REPLACE,
                            ui.window,
                            ui.atoms.XdndActionList,
                            XCB_ATOM_ATOM,
                            32,
                            2,
                            &actions
                        )

                        ui.setDragFileURI(elem.fileURI)                        
                    }
                    break
                }
            }

        } else if ui.draggingStage == 2 {
            if ui.fileDragWindow != null && ui.fileDragWindow.isExposed {
                cpos = ui.fileDragWindow.getCursorPosition()
                cpos = ui.fileDragWindow.toScreenCoord(cpos)
                ui.fileDragWindow.moveTo(cpos[0] - ui.fileDragWindow.width / 2, cpos[1] + 10)
                w = ui.fileDragWindow

                localPos = ui.getCursorPosition()
                if localPos[0] > 0 && localPos[0] < ui.width && localPos[1] > 0 && localPos[1] < ui.height {
                    elem uiElement*
                    i=0; for i < len(ui.elements), i++ {
                        pos = ui.getCursorPosition()
                        elem = _uiElementRecusriveCollideFiltered(ui.elements[i], pos, __ui_filterIsElemDragTarget)
                        if elem != null {
                            __uiSetElementOnFocus(ui, elem)
                            __uiDispatchEvent(ui, elem, uiEventElementFileDrag)
                            break
                        }
                    }

                    if elem == null && ui.focusedElement != null {
                        ui.focusedElement.clicked = false
                        __uiRedrawElement(ui, ui.focusedElement, __uiElementDrawTypeFull)
                        ui.focusedElement.focused = false
                        __uiDispatchEvent(ui, ui.focusedElement, uiEventElementFocusOut)
                        ui.focusedElement = null
                    }
                }

                //get window under the pointer
                ck = xcb_query_pointer(ui.connection, ui.screen.root)
                rep = xcb_query_pointer_reply(ui.connection, ck, null)
                target = rep.child

                for target != 0 {
                    //if the window in xdndaware (support dnd), break
                    propCookie = xcb_get_property(
                        ui.connection,
                        0,
                        target,
                        ui.atoms.XdndAware,
                        XCB_GET_PROPERTY_TYPE_ANY,
                        0, 1
                    )
                    propRep = xcb_get_property_reply(ui.connection, propCookie, null)

                    if propRep == null {
                        target = 0
                        break
                    }                    
                    if propRep.format == 32 {
                        free(propRep)
                        break
                    }
                    free(propRep)

                    //if it is not xdndaware, we may be on a wm frame, fetch its child
                    treeCookie = xcb_query_tree(ui.connection, target)
                    treeRep = xcb_query_tree_reply(ui.connection, treeCookie, null)

                    if treeRep == null {
                        target = 0
                        break
                    }

                    children = xcb_query_tree_children(treeRep)
                    nchildren = xcb_query_tree_children_length(treeRep)
                    if nchildren == 0 {
                        target = 0
                    } else {
                        target = *children
                    }
                    free(treeRep)
                }

                if w.oldTarget != 0 && w.oldTarget != target {
                    ev = xcb_client_message_event_t {
                        response_type: 33
                        format: 32
                        window: target
                        type: ui.atoms.XdndLeave
                    }

                    *(<uint32*>(<uint>&ev.data)) = ui.window

                    xcb_send_event(ui.connection, 0, w.oldTarget, XCB_EVENT_MASK_NO_EVENT, <ptr>&ev)
                    xcb_flush(ui.connection)
                }

                if target != 0 && target != ui.window && target != w.window {
                    if w.oldTarget != target {
                        ev = xcb_client_message_event_t {
                            response_type: 33
                            format: 32
                            window: target
                            type: ui.atoms.XdndEnter
                        }

                        *(<uint32*>(<uint>&ev.data)) = ui.window
                        *(<uint32*>(<uint>&ev.data + 4)) = <uint32>83886081
                        *(<uint32*>(<uint>&ev.data + 8)) = ui.atoms.text_uri_list
                        *(<uint32*>(<uint>&ev.data + 12)) = ui.atoms.text_x_moz_url

                        xcb_send_event(ui.connection, 0, target, XCB_EVENT_MASK_NO_EVENT, <ptr>&ev)
                        xcb_flush(ui.connection)
                    } else {
                        ev = xcb_client_message_event_t {
                            response_type: 33
                            format: 32
                            window: target
                            type: ui.atoms.XdndPosition
                        }

                        evpos = (<uint32>rep.root_x << 16) | <uint32>rep.root_y

                        *(<uint32*>(<uint>ev.data)) = ui.window
                        *(<uint32*>(<uint>ev.data + 8)) = <uint32>evpos
                        *(<uint32*>(<uint>ev.data + 16)) = ui.atoms.XdndActionCopy

                        cookie = xcb_send_event(ui.connection, 0, target, XCB_EVENT_MASK_NO_EVENT, <ptr>&ev)
                        xcb_flush(ui.connection)
                    }
                }
                w.oldTarget = target

                free(rep)
            } else {
                __uiDispatchEvent(ui, ui.focusedElement, uiEventElementHovered)
            }
        }
        
        nb = 0
        cursorChanged = false
        i=0; for i < len(ui.elements), i++ {
            elems = _uiElementRecusriveHover(ui.elements[i], ui, pos)
            nb += elems[1]
            if elems[2] {
                cursorChanged = true
            }
            if elems[0] != null {
                break
            }
        }

        if nb == 0 || cursorChanged == false {
            ui.setCursor("left_ptr")
        }

    } else if event == windowEventMouseDown {
        ui.draggingStage = 1
        pos = ui.getCursorPosition()
        clickedBtn = ui.getEventButton()
        if clickedBtn <= MOUSE_RIGHT_BUTTON {
            i=0; for i < len(ui.elements), i++ {
                elem = _uiElementRecusriveCollide(ui.elements[i], pos)
                if elem != null {
                    __uiDispatchEvent(ui, elem, uiEventElementMouseDown)
                    __uiSetElementOnFocus(ui, elem)
                    break
                }
            }
        }
        if clickedBtn == MOUSE_SCROLL_DOWN {
            i=0; for i < len(ui.elements), i++ {
                elem = _uiElementRecusriveCollideFiltered(ui.elements[i], pos, __ui_filterIsElemScrollableV)
                if elem != null {
                    elem.offsets[1] += 10
                    size = elem.getSize()
                    innerSize = elem.getInnerSize()
                    if elem.offsets[1] + size[1] > innerSize[1] {
                        elem.offsets[1] = innerSize[1] - size[1]
                    }
                    __uiRedrawElement(ui, elem, __uiElementDrawTypeFull)
                    break
                }
            }
        } else if clickedBtn == MOUSE_SCROLL_UP {
            i=0; for i < len(ui.elements), i++ {
                elem = _uiElementRecusriveCollideFiltered(ui.elements[i], pos, __ui_filterIsElemScrollableV)
                if elem != null {
                    elem.offsets[1] -= 10
                    if elem.offsets[1] < 0 {
                        elem.offsets[1] = 0
                    }
                    __uiRedrawElement(ui, elem, __uiElementDrawTypeFull)
                    break
                }
            }
        } else if clickedBtn == MOUSE_SCROLL_RIGHT {
            i=0; for i < len(ui.elements), i++ {
                elem = _uiElementRecusriveCollideFiltered(ui.elements[i], pos, __ui_filterIsElemScrollableH)
                if elem != null {
                    elem.offsets[0] += 10
                    size = elem.getSize()
                    innerSize = elem.getInnerSize()
                    if elem.offsets[0] + size[0] > innerSize[0] {
                        elem.offsets[0] = innerSize[0] - size[0]
                    }
                    __uiRedrawElement(ui, elem, __uiElementDrawTypeFull)
                    break
                }
            }
        } else if clickedBtn == MOUSE_SCROLL_LEFT {
            i=0; for i < len(ui.elements), i++ {
                elem = _uiElementRecusriveCollideFiltered(ui.elements[i], pos, __ui_filterIsElemScrollableH)
                if elem != null {
                    elem.offsets[0] -= 10
                    if elem.offsets[0] < 0 {
                        elem.offsets[0] = 0
                    }
                    __uiRedrawElement(ui, elem, __uiElementDrawTypeFull)
                    break
                }
            }
        }
    } else if event == windowEventMouseUp {
        ui.draggingStage = 0
        if ui.fileDragWindow != null {
            localPos = ui.getCursorPosition()
            if localPos[0] > 0 && localPos[0] < ui.width && localPos[1] > 0 && localPos[1] < ui.height && ui.focusedElement != null {
                __uiDispatchEvent(ui, ui.focusedElement, uiEventElementFileDrop)
            } else {
                w = ui.fileDragWindow
                if w.oldTarget != 0 {
                    m = xcb_client_message_event_t {
                        response_type: 33
                        format: 32
                        window: w.oldTarget
                        type: ui.atoms.XdndDrop
                    }
                    *(<uint32*>(<uint>m.data)) = ui.window

                    xcb_send_event(ui.connection, 0, w.oldTarget, XCB_EVENT_MASK_NO_EVENT, <ptr>&m);
                    xcb_flush(ui.connection)
                    __uiDispatchEvent(ui, ui.fileDragWindow.elem, uiEventElementFileDropOutside)
                }
            }
            ui.fileDragWindow.close()
            ui.fileDragWindow = null
        }

        pos = ui.getCursorPosition()
        clickedBtn = ui.getEventButton()
        if clickedBtn == MOUSE_LEFT_BUTTON {
            if ui.focusedElement != null {
                i=0; for i < len(ui.elements), i++ {
                    elem = _uiElementRecusriveCollide(ui.elements[i], pos)
                    if elem != null {
                        if elem != ui.focusedElement {
                            ui.focusedElement.clicked = false
                            __uiRedrawElement(ui, ui.focusedElement, __uiElementDrawTypeFull)
                            ui.focusedElement.focused = false
                            __uiDispatchEvent(ui, ui.focusedElement, uiEventElementFocusOut)
                            ui.focusedElement = null
                        } else {
                            elem.clicked = false
                            __uiDispatchEvent(ui, elem, uiEventElementClicked)
                            break
                        }
                    }
                }
                if i == len(ui.elements) && ui.focusedElement != null {
                    ui.focusedElement.clicked = false
                    __uiRedrawElement(ui, ui.focusedElement, __uiElementDrawTypeFull)
                    ui.focusedElement.focused = false
                    __uiDispatchEvent(ui, ui.focusedElement, uiEventElementFocusOut)
                    ui.focusedElement = null
                }
            }
        }
    } else if event == windowEventDrag {
        elem uiElement*
        i=0; for i < len(ui.elements), i++ {
            pos = ui.getCursorPosition()
            elem = _uiElementRecusriveCollideFiltered(ui.elements[i], pos, __ui_filterIsElemDragTarget)
            if elem != null {
                __uiSetElementOnFocus(ui, elem)
                __uiDispatchEvent(ui, elem, uiEventElementFileDrag)
                break
            }
        }

        if elem == null && ui.focusedElement != null {
            ui.focusedElement.clicked = false
            __uiRedrawElement(ui, ui.focusedElement, __uiElementDrawTypeFull)
            ui.focusedElement.focused = false
            __uiDispatchEvent(ui, ui.focusedElement, uiEventElementFocusOut)
            ui.focusedElement = null
        }
    } else if event == windowEventDrop && ui.focusedElement != null {
        __uiDispatchEvent(ui, ui.focusedElement, uiEventElementFileDrop)
    }

    if ui.needsRedraw {
        ui.redraw()
        ui.needsRedraw = false
    }
    ui.animationsMutex.unlock()
}

__uiConstructElementTreeRecursively(elem uiElement*) {
    i=0; for i < len(elem.elements), i++ {
        elem.elements[i].parent = elem
        elem.elements[i].window = elem.window
        __uiConstructElementTreeRecursively(elem.elements[i])
    }
}

__uiComposeElementTreeRecursively(elem uiElement*) {
    i=0; for i < len(elem.elements), i++ {
        __uiComposeElementTreeRecursively(elem.elements[i])
    }
    __uiForceDrawElement(elem.window, elem)
}