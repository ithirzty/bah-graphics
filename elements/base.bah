#import "../graphics.bah"
#import "time.bah"

const __uiElementDrawTypeFull = 0
const __uiElementDrawTypeChildren = 1
const __uiElementDrawTypeBackground = 2

#define __uiRedrawElement(ui window*, elem ptr, drawType int)
#define __uiRedrawElementDelayed(ui window*, elem ptr, ms uint)

const _uiPosFlagPx     = 1
const _uiPosFlagPc     = 2
const _uiPosFlagOpAdd  = 4
const _uiPosFlagOpSub  = 8
const _uiPosFlagOpMult = 16
const _uiPosFlagOpDiv  = 32
const _uiPosFlagRef    = 64
const _uiPosFlagRefID  = 128

const uiBasisCenter = 1024
const uiBasisEnd    = 2048

struct uiPos {
    ammount: int32
    flags: int32
    children: [ptr,ptr]

    basis(bs int32) uiPos {
        this.flags = this.flags | bs
        return *this
    }

    add(x uiPos) uiPos {
        a = new uiPos
        *a = *this
        b = new uiPos
        *b = x
        return uiPos {
            flags: _uiPosFlagOpAdd
            children: [a, b]
        }
    }

    sub(x uiPos) uiPos {
        a = new uiPos
        *a = *this
        b = new uiPos
        *b = x
        return uiPos {
            flags: _uiPosFlagOpSub
            children: [a, b]
        }
    }
}

const nullPos = uiPos{0}

pixels(px int) uiPos {
    return uiPos {
        ammount: px
        flags: _uiPosFlagPx
    }
}

percents(pc int) uiPos {
    return uiPos {
        ammount: pc
        flags: _uiPosFlagPc
    }
}

sizeOfElement(elem ptr) uiPos {
    return uiPos {
        flags: _uiPosFlagRef
        children: [elem, null]
    }
}

sizeOfElementById(id str) uiPos {
    return uiPos {
        flags: _uiPosFlagRefID
        children: [id, null]
    }
}

isPosNull(vec uiPos) bool {
    return vec.flags == 0
}

#define __uiCalculateElemPosVec(elem ptr, posVec [uiPos,uiPos], absPos bool) [int,int]
#define __uiConstructElementTreeRecursively(elem ptr)
#define __uiComposeElementTreeRecursively(elem ptr)

struct uiContextItem {
    ctrl: bool = true
    shift: bool
    alt: bool
    key: uint32
    name: str

    callback: function(uiContextItem*, ptr)
}

struct uiElement {
    pos: [uiPos,uiPos]
    size: [uiPos,uiPos]
    padding: [uint,uint,uint,uint]
    innerMargin: [uint,uint,uint,uint]
    offsets: [int,int]
    fontSize: uint
    cursor: str
    absolutePosition: bool
    focusable: bool = true
    manualDrawingMode: bool = false
    dragTarget: bool
    id: str
    fileURI: str
    lastDraw: int

    elements: []uiElement*
    parent: uiElement*
    window: window*
    contextItems: []uiContextItem

    maskHash: int

    toRemove: bool

    hovered: bool
    clicked: bool
    focused: bool

    _events: function(uiElement*, uint32)
    _draw: function(uiElement*, window*)

    find(id str) uiElement* {
        if this.id == id {
            return this
        }

        i=0; for i < len(this.elements), i++ {
            f = this.elements[i].find(id)
            if f != null {
                return f
            }
        }

        return null
    }

    getSize() [int,int] {
        return __uiCalculateElemPosVec(this, this.size, false)
    }

    getPosition() [int,int] {
        r = __uiCalculateElemPosVec(this, this.pos, true)
        
        if this.parent != null {
            parentPos = this.parent.getPosition()
            r[0] += parentPos[0]
            r[1] += parentPos[1]

            if this.absolutePosition == false {
                r[0] -= this.parent.offsets[0]
                r[1] -= this.parent.offsets[1]
            }
        }
        return r
    }

    getInnerSize() [uint,uint] {
        innerSize = [0,0]
        thisPos = this.getPosition()
        i=0; for i < len(this.elements), i++ {
            if this.elements[i].absolutePosition {
                continue
            }
            ePos = this.elements[i].getPosition()
            eSize = this.elements[i].getSize()

            x = ePos[0] + eSize[0] - thisPos[0]
            y = ePos[1] + eSize[1] - thisPos[1]

            if x > innerSize[0] {
                innerSize[0] = x
            }

            if y > innerSize[1] {
                innerSize[1] = y
            }
        }

        innerSize[1] += this.offsets[1] + this.padding[3]
        innerSize[0] += this.offsets[0] + this.padding[2]

        return innerSize
    }

    remove() {
        this.toRemove = true
    }

    hashChanged() bool {
        pos = this.getPosition()
        size = this.getSize()
        newHash = pos[0] + pos[1] * 16384 + size[0] * 32768 + size[1] * 49152
        if this.maskHash != newHash {
            this.maskHash = newHash
            return true
        }
        return false
    }

    addElement(elem uiElement*) {
        elem.parent = this
        elem.window = this.window
        this.elements[len(this.elements)] = elem
        if this.window != null {
            __uiConstructElementTreeRecursively(elem)
            __uiComposeElementTreeRecursively(elem)

            if this.parent != null && this.window != null {
                __uiRedrawElement(this.window, this, __uiElementDrawTypeFull)
            }
        }
    }

    addElementNoRedraw(elem uiElement*) {
        elem.parent = this
        elem.window = this.window
        this.elements[len(this.elements)] = elem
        if this.window != null {
            __uiConstructElementTreeRecursively(elem)
            __uiComposeElementTreeRecursively(elem)
        }
    }

    redrawIn(ms uint) {
        __uiRedrawElementDelayed(this.window, this, ms)
    }

    redraw() {
        __uiRedrawElement(this.window, this, __uiElementDrawTypeFull)
    }
}

#define __uiFindElement(ui window*, id str) uiElement*

__uiCalculateElemPosX(this uiElement*, pos uiPos, absPos bool) int {
    r = 0
    if pos.flags & _uiPosFlagOpAdd != 0 {
        if pos.children[0] != null && pos.children[1] != null {
            a = __uiCalculateElemPosX(this, *<uiPos*>pos.children[0], absPos)
            b = __uiCalculateElemPosX(this, *<uiPos*>pos.children[1], absPos)
            r = a + b
        }
    } else if pos.flags & _uiPosFlagOpSub != 0 {
        if pos.children[0] != null && pos.children[1] != null {
            a = __uiCalculateElemPosX(this, *<uiPos*>pos.children[0], absPos)
            b = __uiCalculateElemPosX(this, *<uiPos*>pos.children[1], absPos)
            r = a - b
        }
    } else if pos.flags & _uiPosFlagOpMult != 0 {
        if pos.children[0] != null && pos.children[1] != null {
            a = __uiCalculateElemPosX(this, *<uiPos*>pos.children[0], absPos)
            b = __uiCalculateElemPosX(this, *<uiPos*>pos.children[1], absPos)
            r = a * b
        }
    } else if pos.flags & _uiPosFlagOpDiv != 0 {
        if pos.children[0] != null && pos.children[1] != null {
            a = __uiCalculateElemPosX(this, *<uiPos*>pos.children[0], absPos)
            b = __uiCalculateElemPosX(this, *<uiPos*>pos.children[1], absPos)
            r = a / b
        }
    } else if pos.flags & _uiPosFlagRefID != 0 {
        elem = __uiFindElement(this.window, pos.children[0])
        if elem != null {
            r = elem.getSize()[0]
        }
    } else if pos.flags & _uiPosFlagRef != 0 {
        elem = <uiElement*>pos.children[0]
        if elem != null {
            r = elem.getSize()[0]
        }
    } else if pos.flags & _uiPosFlagPx != 0 {
        r = pos.ammount
    } else if pos.flags & _uiPosFlagPc != 0 {
        parWidth = 0
        if this.parent != null {
            parWidth = this.parent.getSize()[0] - (this.parent.padding[0] + this.parent.padding[2])
        } else {
            parWidth = this.window.width
        }

        r = <int>(<float>parWidth * (<float><int>pos.ammount / 100.0))
    }

    if this.parent != null && this.absolutePosition == false && absPos {
        r += this.parent.padding[0]
    }

    if pos.flags & uiBasisCenter != 0 {
        r -= this.getSize()[0] / 2
    } else if pos.flags & uiBasisEnd != 0 {
        r -= this.getSize()[0]
    }

    return r
}

__uiCalculateElemPosY(this uiElement*, pos uiPos, absPos bool) int {
    r = 0
    if pos.flags & _uiPosFlagOpAdd != 0 {
        if pos.children[0] != null && pos.children[1] != null {
            a = __uiCalculateElemPosY(this, *<uiPos*>pos.children[0], absPos)
            b = __uiCalculateElemPosY(this, *<uiPos*>pos.children[1], absPos)
            r = a + b
        }
    } else if pos.flags & _uiPosFlagOpSub != 0 {
        if pos.children[0] != null && pos.children[1] != null {
            a = __uiCalculateElemPosY(this, *<uiPos*>pos.children[0], absPos)
            b = __uiCalculateElemPosY(this, *<uiPos*>pos.children[1], absPos)
            r = a - b
        }
    } else if pos.flags & _uiPosFlagOpMult != 0 {
        if pos.children[0] != null && pos.children[1] != null {
            a = __uiCalculateElemPosY(this, *<uiPos*>pos.children[0], absPos)
            b = __uiCalculateElemPosY(this, *<uiPos*>pos.children[1], absPos)
            r = a * b
        }
    } else if pos.flags & _uiPosFlagOpDiv != 0 {
        if pos.children[0] != null && pos.children[1] != null {
            a = __uiCalculateElemPosY(this, *<uiPos*>pos.children[0], absPos)
            b = __uiCalculateElemPosY(this, *<uiPos*>pos.children[1], absPos)
            r = a / b
        }
    } else if pos.flags & _uiPosFlagRefID != 0 {
        elem = __uiFindElement(this.window, pos.children[0])
        if elem != null {
            r = elem.getSize()[1]
        }
    } else if pos.flags & _uiPosFlagRef != 0 {
        elem = <uiElement*>pos.children[0]
        if elem != null {
            r = elem.getSize()[1]
        }
    } else if pos.flags & _uiPosFlagPx != 0 {
        r = pos.ammount
    } else if pos.flags & _uiPosFlagPc != 0 {
        parHeight = 0
        if this.parent != null {
            parHeight = this.parent.getSize()[1] - (this.parent.padding[1] + this.parent.padding[3])
        } else {
            parHeight = this.window.height
        }

        r = <int>(<float>parHeight * (<float><int>pos.ammount / 100.0))
    }

    if this.parent != null && this.absolutePosition == false && absPos {
        r += this.parent.padding[1]
    }

    if pos.flags & uiBasisCenter != 0 {
        r -= this.getSize()[1] / 2
    } else if pos.flags & uiBasisEnd != 0 {
        r -= this.getSize()[1]
    }

    return r
}

__uiCalculateElemPosVec(this uiElement*, pos [uiPos,uiPos], absPos bool) [int,int] {
    return [__uiCalculateElemPosX(this, pos[0], absPos), __uiCalculateElemPosY(this, pos[1], absPos)]
}