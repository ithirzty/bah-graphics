#import "../graphics.bah"
#import "time.bah"

const __uiElementDrawTypeFull = 0
const __uiElementDrawTypeChildren = 1
const __uiElementDrawTypeBackground = 2

#define __uiRedrawElement(ui window*, elem ptr, drawType int)
#define __uiRedrawElementDelayed(ui window*, elem ptr, ms uint)

const _uiPosFlagPx = 1
const _uiPosFlagPc = 2

const uiBasisCenter = 1024
const uiBasisEnd    = 2048

struct uiPos {
    ammount: int16
    flags: int16

    basis(bs int16) uiPos {
        this.flags = this.flags | bs
        return *this
    }
}

pixels(px int) uiPos {
    return uiPos {
        ammount: px
        flags: _uiPosFlagPx
    }
}

percents(pc int) uiPos {
    return uiPos {
        ammount: pc
        flags: _uiPosFlagPc
    }
}

#define __uiCalculateElemPosVec(elem ptr, posVec [uiPos,uiPos], absPos bool) [int,int]
#define __uiConstructElementTreeRecursively(elem ptr)
#define __uiComposeElementTreeRecursively(elem ptr)

struct uiContextItem {
    ctrl: bool = true
    shift: bool
    alt: bool
    key: uint32
    name: str

    callback: function(uiContextItem*, ptr)
}

struct uiElement {
    pos: [uiPos,uiPos]
    margin: [uiPos,uiPos]
    size: [int,int]
    padding: [uint,uint,uint,uint]
    innerMargin: [uint,uint,uint,uint]
    offsets: [int,int]
    fontSize: uint
    cursor: str
    absolutePosition: bool
    id: str

    elements: []uiElement*
    parent: uiElement*
    window: window*
    contextItems: []uiContextItem

    maskHash: int

    toRemove: bool
    focusable: bool = true
    manualDrawingMode: bool = false

    hovered: bool
    clicked: bool
    focused: bool

    _events: function(uiElement*, uint32)
    _draw: function(uiElement*, window*)

    find(id str) uiElement* {
        if this.id == id {
            return this
        }

        i=0; for i < len(this.elements), i++ {
            f = this.elements[i].find(id)
            if f != null {
                return f
            }
        }

        return null
    }

    getSize() [int,int] {
        size = this.size
        return size
    }

    getMargin() [int,int] {
        return __uiCalculateElemPosVec(this, this.margin, false)
    }

    getPosition() [int,int] {
        margin = __uiCalculateElemPosVec(this, this.margin, false)
        r = __uiCalculateElemPosVec(this, this.pos, true)
        r[0] += margin[0]
        r[1] += margin[1]

        if this.parent != null {
            parentPos = this.parent.getPosition()
            r[0] += parentPos[0]
            r[1] += parentPos[1]

            if this.absolutePosition == false {
                r[0] -= this.parent.offsets[0]
                r[1] -= this.parent.offsets[1]
            }
        }
        return r
    }

    getInnerSize() [uint,uint] {
        innerSize = [0,0]
        thisPos = this.getPosition()
        i=0; for i < len(this.elements), i++ {
            if this.elements[i].absolutePosition {
                continue
            }
            ePos = this.elements[i].getPosition()
            eSize = this.elements[i].getSize()

            x = ePos[0] + eSize[0] - thisPos[0]
            y = ePos[1] + eSize[1] - thisPos[1]

            if x > innerSize[0] {
                innerSize[0] = x
            }

            if y > innerSize[1] {
                innerSize[1] = y
            }
        }

        innerSize[1] += this.offsets[1] + this.padding[3]
        innerSize[0] += this.offsets[0] + this.padding[2]

        return innerSize
    }

    remove() {
        this.toRemove = true
    }

    hashChanged() bool {
        pos = this.getPosition()
        size = this.getSize()
        newHash = pos[0] + pos[1] * 16384 + size[0] * 32768 + size[1] * 49152
        if this.maskHash != newHash {
            this.maskHash = newHash
            return true
        }
        return false
    }

    addElement(elem uiElement*) {
        elem.parent = this
        elem.window = this.window
        this.elements[len(this.elements)] = elem
        if this.window != null {
            __uiConstructElementTreeRecursively(elem)
            __uiComposeElementTreeRecursively(elem)

            if this.parent != null && this.window != null {
                __uiRedrawElement(this.window, this, __uiElementDrawTypeFull)   
            }
        }
    }

    redrawIn(ms uint) {
        __uiRedrawElementDelayed(this.window, this, ms)
    }

    redraw() {
        __uiRedrawElement(this.window, this, __uiElementDrawTypeFull)
    }
}

__uiCalculateElemPosVec(this uiElement*, pos [uiPos,uiPos], absPos bool) [int,int] {
    r = [0,0]

    if pos[0].flags & _uiPosFlagPx != 0 {
        r[0] = pos[0].ammount
    } else if pos[0].flags & _uiPosFlagPc != 0 {
        parWidth = 0
        if this.parent != null {
            parWidth = this.parent.getSize()[0] - (this.parent.padding[0] + this.parent.padding[2])
        } else {
            parWidth = this.window.width
        }

        r[0] = <int>(<float>parWidth * (<float><int>pos[0].ammount / 100.0))
    }

    if this.parent != null && this.absolutePosition == false && absPos {
        r[0] += this.parent.padding[0]
        r[1] += this.parent.padding[1]
    }

    if pos[1].flags & _uiPosFlagPx != 0 {
        r[1] = pos[1].ammount
    } else if pos[1].flags & _uiPosFlagPc != 0 {
        parHeight = 0
        if this.parent != null {
            parHeight = this.parent.getSize()[1] - (this.parent.padding[1] + this.parent.padding[3])
        } else {
            parHeight = this.window.height
        }

        r[1] = <int>(<float>parHeight * (<float><int>pos[1].ammount / 100.0))
    }

    if pos[0].flags & uiBasisCenter != 0 {
        r[0] -= this.getSize()[0] / 2
    } else if pos[0].flags & uiBasisEnd != 0 {
        r[0] -= this.getSize()[0]
    }

    if pos[1].flags & uiBasisCenter != 0 {
        r[1] -= this.getSize()[1] / 2
    } else if pos[1].flags & uiBasisEnd != 0 {
        r[1] -= this.getSize()[1]
    }

    return r
}