#import "../ui_struct.bah"

#import "./base.bah"

UI_TEXT_COLOR = rgbColor{0, 0, 0}
UI_TEXT_SELECTION_COLOR = rgbColor{120, 120, 255}
UI_TEXT_SELECTION_COLOR_FOCUSED_OUT = rgbColor{120, 120, 120}

struct uiText extend uiElement {
    text: str = ""
    color: rgbColor
    bgColor: rgbColor = rgbColor{0,0,0,0}
            //pixel coords, text offset
    selBeg: [int, int, int]
    selEnd: [int, int, int]
    isSel: bool


    //character offset, line start character offset, line number, x pixel offset of character
    _getTextPosition(cursorPos [int, int]) [int, int, int, int] {
        ui = <ui*>this.window
        pos = this.getPosition()

        if cursorPos[0] > ui.width || cursorPos[1] > ui.height {
            return [0, 0, 0, 0]
        }

        relPos = [
            cursorPos[0] - pos[0] - <int>this.padding[0],
            cursorPos[1] - pos[1] - <int>this.padding[1]
        ]

        lineNb = relPos[1] / (this.fontSize + this.fontSize / 2)
        
        arr = strAsArr(this.text)

                // n, start
        currLine = [0, 0]
        i=0; for i < len(this.text), i++ {
            if this.text[i] == <char>10 {
                currLine[0]++

                if currLine[0] == lineNb {
                    currLine[1] = i
                } else if currLine[0] == lineNb+1 {
                    currLine[0]--
                    break
                }
            }
        }

        currDim = 0

        for i > currLine[1] - 1, i-- {
            currDim = this.window.measureByteArr(ui.font, <[]byte>&arr, currLine[1], i)[0]

            if <int>currDim <= relPos[0] {
                break
            }
        }

        return [i, currLine[1], currLine[0], currDim]
    }

    getSelection() str {
        sel = [this.selBeg[2], this.selEnd[2]]
        selDist = sel[1] - sel[0]

        if selDist < 0 {
            selDist = 0 - selDist
            tmp = sel[1]
            sel[1] = sel[0]
            sel[0] = tmp
        }

        if selDist == 0 {
            return ""
        }

        return this.text[sel[0]:sel[1]]
    }

    events(evnt uint32) {
        if this.focusable == false {
            return
        }

        ui = <ui*>this.window
        cursorPos = this.window.getCursorPosition()

        if evnt == uiEventElementFocusOut {
            if this.isSel {
                this.isSel = false
            } else {
                this.selEnd = this.selBeg
            }
        } else {
            if ui.getEventButton() == MOUSE_LEFT_BUTTON {
                if evnt == uiEventElementMouseDown {
                    this.isSel = true
                    // this.cursor = "xterm"
                    // this.window.setCursor("xterm")
                    textPos = this._getTextPosition(cursorPos)
                    this.selBeg = [
                        textPos[3],
                        textPos[2] * (this.fontSize + this.fontSize / 2),
                        textPos[0]
                    ]
                    this.selEnd = this.selBeg
                    this.redraw()
                } else if this.isSel {
                    textPos = this._getTextPosition(cursorPos)
                    if evnt == uiEventElementClicked {
                        // this.cursor = "null"
                        // this.window.setCursor(this.cursor)
                        this.isSel = false
                    } else {
                        this.selEnd = [
                            textPos[3],
                            textPos[2] * (this.fontSize + this.fontSize / 2),
                            textPos[0]
                        ]
                        this.redraw()
                    }
                }
            }
        }


    }

    setText(s str) {
        this.text = s
        ui = <ui*>this.window
        ui.font.setSize(this.fontSize)
        txtSize = this.window.measureText(ui.font, this.text)
        this.size = [
            pixels(txtSize[0] + this.padding[0] * 2),
            pixels(txtSize[1] + this.padding[1] * 2)
        ]
        this.selBeg[2] = 0
        this.selEnd[2] = 0
        this.redraw()
    }

    draw(w ui*) {
        w.font.setSize(this.fontSize)

        pos = this.getPosition()

        if isPosNull(this.size[0]) || isPosNull(this.size[1]) {
            txtSize = this.window.measureText(w.font, this.text)
            this.size = [
                pixels(txtSize[0] + this.padding[0] * 2),
                pixels(txtSize[1] + this.padding[1] * 2)
            ]
        }
        
        size = this.getSize()

        w.drawRect(pos, size, this.bgColor)

        selDist = this.selBeg[2] - this.selEnd[2]
        if selDist < 0 {
            selDist = 0 - selDist
        }

        if selDist != 0 {
            arr = strAsArr(this.text)

            // currDim = this.window.measureByteArr(ui.font, <[]byte>&arr, currLine[1], i)[0]

            selStart = this.selBeg
            selEnd = this.selEnd
            if this.selBeg[2] > this.selEnd[2] {
                selStart = this.selEnd
                selEnd = this.selBeg
            }

            startPos = [selStart[0] + pos[0], selStart[1] + pos[1]]

            selColor = UI_TEXT_SELECTION_COLOR
            if this.focused == false {
                selColor = UI_TEXT_SELECTION_COLOR_FOCUSED_OUT
            }

            startInd = selStart[2]
            i = selStart[2]; for i < selEnd[2], i++ {
                if this.text[i] == <char>10 {
                    currDim = this.window.measureByteArr(w.font, <[]byte>&arr, startInd, i)[0]
                    w.drawRect(startPos, [currDim, this.fontSize + this.fontSize / 2], selColor)
                    startPos = [pos[0], startPos[1] + this.fontSize + this.fontSize / 2]
                    startInd = i + 1
                }

                if this.window.scissor[0] && startPos[1] > this.window.scissor[4] {
                    break
                }
            }

            currDim = this.window.measureByteArr(w.font, <[]byte>&arr, startInd, i)[0]
            w.drawRect(startPos, [currDim, this.fontSize + this.fontSize / 2], selColor)

        }

        w.drawText(w.font, this.text, this.color, [pos[0] + this.padding[0], pos[1] + this.padding[1] + this.fontSize])
    }

    _init() {
        this._events = this.events
        this._draw = this.draw
        
        if this.color.a == 0 {
            this.color = UI_TEXT_COLOR
        }

        if this.fontSize == 0 {
            this.fontSize = 8
        }

        if this.padding[0] == 0 {
            this.padding = [0, this.fontSize / 2, 0, 0]
        }

        if this.focusable {
            this.cursor = "xterm"
        }

        this.contextItems[len(this.contextItems)] = uiContextItem {
            key: 'c'
            name: "Copy selected text."

            callback: function(ci uiContextItem*, txt uiText*) {
                sel = txt.getSelection()
                txt.window.setClipboard(sel)
            }
        }

        this.contextItems[len(this.contextItems)] = uiContextItem {
            key: 'a'
            name: "Select all text."

            callback: function(ci uiContextItem*, txt uiText*) {
                txt.selBeg[2] = 0
                txt.selBeg[0] = 0
                txt.selBeg[1] = 0

                txt.selEnd[2] = len(txt.text)
            }
        }
        
    }
}