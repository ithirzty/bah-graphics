#import "iostream.bah"
#import "string.bah"
#import "channel.bah"

#import "./libs/xcb.bah"
#import "./libs/shm.bah"
#import "./libs/math.bah"

#import "./colors.bah"
#import "./fonts.bah"
#import "./keys.bah"
#import "./images.bah"

const windowEventInitialize = 0
const windowEventDraw = 1
const windowEventMouseMove = 2
const windowEventClose = 3
const windowEventMouseDown = 4
const windowEventMouseUp = 5
const windowEventKeyDown = 6
const windowEventKeyUp = 7
const windowEventFocusIn = 8
const windowEventFocusOut = 9
const windowEventResize = 10

const __graphicsDrawRequestTypeRect = 0
const __graphicsDrawRequestTypeCircle = 1
const __graphicsDrawRequestTypeRectImg = 2

const __graphicsNbDrawers = 2 // Max: 8

struct __graphicsDrawRequest {
    from: [int,int]
    to: [int,int]
    color: rgbColor*
    type: byte
}

xcb_getAtom(connection ptr, name str) uint32 {
    cookie = xcb_intern_atom(connection, 0, len(name), cStr(name))
    reply = xcb_intern_atom_reply(connection, cookie, null)

    if reply == null {
        println("error getting X atom: "+name)
        return 0
    }

    atom = reply.atom
    free(reply)
    return atom
}

struct window {
    connection: ptr
    screen: xcb_screen_t*
    window: uint32
    keySyms: ptr
    cursorCtx: ptr
    frameBuffer: byte*
    events: function(window*, uint32)

    width: uint
    height: uint
    scissor: [bool,int,int,int,int]

    lastKeyCode: byte
    lastMouseCode: byte
    keyModifiers: uint
    shiftLock: bool

    isExposed: bool
    isRunning: bool
    hasDrawn: bool

    tmpClipboard: str
    clipboardChan: channel*
    tmpClipboardAtoms: [uint32, uint32]
    
    callEventFunction(event uint32) {
        eventFn = this.events
        if eventFn == null {
            return
        }

        eventFn(this, event)
    }

    isKeyModifier(keyMod uint32) bool {
        if keyMod == Key_CTRL {
            return this.keyModifiers & 0x01 != 0
        }

        if keyMod == Key_SHIFT || keyMod == Char_left_shift || keyMod == Char_right_shift {
            return this.keyModifiers & 0x02 != 0
        }

        if keyMod == Key_ALT {
            return this.keyModifiers & 0x04 != 0
        }

        if keyMod == Key_ALT_GR {
            return this.keyModifiers & 0x08 != 0
        }

        return false
    }

    getEventKey() byte {
        return this.lastKeyCode
    }

    getEventChar() uint32 {
        col = 0
        if this.isKeyModifier(Key_SHIFT) || this.shiftLock {
            col = 1
        }
        n = xcb_key_symbols_get_keysym(this.keySyms, this.lastKeyCode, col)
        if n == 0 {
            n = xcb_key_symbols_get_keysym(this.keySyms, this.lastKeyCode, 0)
        }
        return n
    }

    getEventButton() byte {
        return this.lastMouseCode
    }

    getCursorPosition() [int, int] {
        cookie = xcb_query_pointer(this.connection, this.window)
        reply = xcb_query_pointer_reply(this.connection, cookie, null)

        return [<uint>reply.win_x, <uint>reply.win_y]
    }

    setClipboard(s str) {
        clipboard = xcb_getAtom(this.connection, "CLIPBOARD")
        xcb_set_selection_owner(this.connection, this.window, clipboard, 0)
        this.tmpClipboard = s
        xcb_flush(this.connection)
    }

    getClipboard(callback function(window*, str, ptr), data ptr) {
        clipboard = xcb_getAtom(this.connection, "CLIPBOARD")
        utf8 = xcb_getAtom(this.connection, "UTF8_STRING")
        prop = xcb_getAtom(this.connection, "XSEL_DATA")

        this.tmpClipboardAtoms = [prop, utf8]

        xcb_convert_selection(
            this.connection,
            this.window,
            clipboard,
            utf8,
            prop,
            0
        )
        xcb_flush(this.connection)

        waitOnResp = function(w window*, cb function(window*, str, ptr), data ptr) {
            resp = <str>w.clipboardChan.receive()
            cb(w, resp, data)
        }

        async waitOnResp(this, callback, data)
    }

    setCursor(name str) {
        if len(name) == 0 {
            name = "left_ptr"
        }

        cursor = xcb_cursor_load_cursor(this.cursorCtx, name)
        xcb_change_window_attributes(this.connection, this.window, XCB_CW_CURSOR, &cursor)
    }

    redraw() {
        xcb_clear_area(this.connection, 1, this.window, 0, 0, 0, 0)
        xcb_flush(this.connection)
    }

    close() {
        ev = xcb_client_message_event_t{
            response_type: 33
            format: 32
            window: this.window
            type: 68
        }

        xcb_send_event(
            this.connection,
            0,
            this.window,
            XCB_EVENT_MASK_NO_EVENT,
            <ptr>&ev
        )
        xcb_flush(this.connection)
    }

    setScissor(pos [int,int], size [int, int]) {
        this.scissor = [true, pos[0], pos[1], pos[0] + size[0], pos[1] + size[1]]
    }

    disableScissor() {
        this.scissor[0] = false
    }

    setPixel(pos [int,int], color rgbColor) {
        offset = (pos[1] * this.width + pos[0]) * 4

        if offset < 0 || offset >= this.width * this.height * 4 {
            return
        }

        if this.scissor[0] && (pos[0] < this.scissor[1] || pos[0] >= this.scissor[3] || pos[1] < this.scissor[2] || pos[1] >= this.scissor[4]) {
            return
        }

        if color.a != 255 {
            da = <float><uint>color.a / 255.0
            ida = 1.0 - da

            color.b = <uint>(<float><uint>color.b * da + <float><uint>*(<byte*>(<uint>this.frameBuffer + offset))     * ida)
            color.g = <uint>(<float><uint>color.g * da + <float><uint>*(<byte*>(<uint>this.frameBuffer + offset + 1)) * ida)
            color.r = <uint>(<float><uint>color.r * da + <float><uint>*(<byte*>(<uint>this.frameBuffer + offset + 2)) * ida)
        }

        v = (<uint32>color.b) | (<uint32>color.g << 8) | (<uint32>color.r << 16)
        *(<uint32*>(<uint>this.frameBuffer + offset)) = v
    }

    __unsafeFastSetPixel(offset uint, l uint, color rgbColor) {
        l += offset
        if color.a != 255 {
            da = <float><uint>color.a / 255.0
            ida = 1.0 - da

            for offset < l, offset++ {
                color.b = <uint>(<float><uint>color.b * da + <float><uint>*(<byte*>(<uint>this.frameBuffer + offset))     * ida)
                color.g = <uint>(<float><uint>color.g * da + <float><uint>*(<byte*>(<uint>this.frameBuffer + offset + 1)) * ida)
                color.r = <uint>(<float><uint>color.r * da + <float><uint>*(<byte*>(<uint>this.frameBuffer + offset + 2)) * ida)
                v = (<uint32>color.b) | (<uint32>color.g << 8) | (<uint32>color.r << 16)
                *(<uint32*>(<uint>this.frameBuffer + offset)) = v
            }

            return
        }

        v = (<uint32>color.b) | (<uint32>color.g << 8) | (<uint32>color.r << 16)
        for offset < l, offset++ {
            *(<uint32*>(<uint>this.frameBuffer + offset * 4)) = v
        }
    }

    currentGraphicsRequest: __graphicsDrawRequest
    haveFrame: mutexCondition
    haveFrameMut: mutex
    haveFrameBool: int
    frameDone: byte

    __threadedDrawer(m uint) {
        req = &this.currentGraphicsRequest

        if req.type == __graphicsDrawRequestTypeRect {
            nbLines = ((req.to[1] - req.from[1]) / (__graphicsNbDrawers + 1))
            localFrom = req.from[1] + m * nbLines
            localTo = localFrom + nbLines
            y = localFrom
            x = req.from[0]
            l = req.to[0] - x
            c = *req.color
            if m == __graphicsNbDrawers {
                localTo = req.to[1]
            }
            for y < localTo, y++ {
                this.__unsafeFastSetPixel(y * this.width + x, l, c)
            }
        }
    }

    __drawThreadworker(m uint) {
        myHaveFrame = <byte*>(<uint>&this.haveFrameBool + m)
        for true {
            this.haveFrameMut.lock()
            for *myHaveFrame == <byte>0 {
                this.haveFrame.wait(this.haveFrameMut)

                if this.isRunning == false {
                    return
                }
            }
            *myHaveFrame = <byte>0
            this.haveFrameMut.unlock()
            
            if this.isRunning == false {
                return
            }

            this.__threadedDrawer(m)

            atomic_add(&this.frameDone, 1)
        }
    }

    __drawRequest(req __graphicsDrawRequest) {
        this.haveFrameMut.lock()
        atomic_store(&this.frameDone, 0)
        this.currentGraphicsRequest = req
        this.haveFrameBool = ~0
        this.haveFrame.broadcast()
        this.haveFrameMut.unlock()

        this.__threadedDrawer(0)

        for atomic_load(&this.frameDone) != __graphicsNbDrawers {
            sched_yield()
        }
    }

    getRect(pos [int, int], size [uint, uint], buff []rgbColor) {
        n = 0
        y=pos[1]; for y < pos[1] + size[1], y++ {
            if y < 0 {
                continue
            }

            if y >= this.height {
                break
            }

            x = pos[0]; for x < pos[0] + size[0], x++ {

                if x < 0 {
                    continue
                }

                if x >= this.width {
                    break
                }

                if this.scissor[0] {
                    if x < this.scissor[1]|| y < this.scissor[2] {
                        continue
                    }
                    
                    if x >= this.scissor[3] || y >= this.scissor[4] {
                        break
                    }
                }

                offset = (y * this.width + x) * 4
                color = rgbColor{}
                color.b = *(<byte*>(<uint>this.frameBuffer + offset))
                color.g = *(<byte*>(<uint>this.frameBuffer + offset + 1))
                color.r = *(<byte*>(<uint>this.frameBuffer + offset + 2))
                buff[n] = color
                n++
            }
        }
    }

    drawRect(pos [int, int], size [int, int], color rgbColor) {
        if color.a == 0 || size[0] < 0 || size[1] < 0 {
            return
        }
        this.hasDrawn = true
        max = [pos[0] + size[0], pos[1] + size[1]]

        if this.scissor[0] {
            if pos[0] < this.scissor[1] {
                pos[0] = this.scissor[1]
            }

            if pos[1] < this.scissor[2] {
                pos[1] = this.scissor[2]
            }

            if max[0] > this.scissor[3] {
                max[0] = this.scissor[3]
            }

            if max[1] > this.scissor[4] {
                max[1] = this.scissor[4]
            }
        }

        if pos[0] < 0 {
            pos[0] = 0
        }

        if pos[1] < 0 {
            pos[1] = 0
        }

        if max[0] > this.width {
            max[0] = this.width
        }

        if max[1] > this.height {
            max[1] = this.height
        }

        if max[0] == pos[0] || max[1] == pos[1] {
            return
        }

        if size[0] * size[1] > 100000 {
            this.__drawRequest(__graphicsDrawRequest{
                from: pos
                to: max
                color: &color
                type: __graphicsDrawRequestTypeRect
            })
            return
        }


        l = max[0] - pos[0]
        y=pos[1]; for y < max[1], y++ {
            this.__unsafeFastSetPixel(y * this.width + pos[0], l, color)
        }
    }

    drawRectImage(pos [int, int], size [uint, uint], buff []rgbColor) {        
        n = 0
        max = [pos[0] + size[0], pos[1] + size[1]]
        this.hasDrawn = true

        if this.scissor[0] {
            if pos[0] < this.scissor[1] {
                pos[0] = this.scissor[1]
            }

            if pos[1] < this.scissor[2] {
                n += (this.scissor[2] - pos[1]) * size[0]
                pos[1] = this.scissor[2]
            }

            if max[0] > this.scissor[3] {
                max[0] = this.scissor[3]
            }

            if max[1] > this.scissor[4] {
                max[1] = this.scissor[4]
            }
        }

        // if size[0] * size[1] > 100000 {
            // this.__drawRequest(__graphicsDrawRequest{
            //     from: pos
            //     to: max
            //     color: <ptr>buff
            //     type: __graphicsDrawRequestTypeRectImg
            // })
            // return
        // }


        y=pos[1]; for y < max[1], y++ {
            if y >= this.height || y < 0 {
                continue
            }
            x = pos[0]; for x < max[0], x++ {
                if x >= this.width || x < 0 {
                    continue
                }

                if n >= len(buff) {
                    break
                }
                if n < 0 {
                    continue
                }
                
                this.setPixel([x,y], buff[n])
                n++
            }
        }
    }

    drawCircle(pos [int, int], radi uint, color rgbColor) {
        if color.a == 0 {
            return
        }
        this.hasDrawn = true
        fradi = <float>radi

        rect = [pos[0] - radi, pos[1] - radi, pos[0] + radi, pos[1] + radi]

        if this.scissor[0] {
            if rect[0] < this.scissor[1] {
                rect[0] = this.scissor[1]
            }

            if rect[1] < this.scissor[2] {
                rect[1] = this.scissor[2]
            }

            if rect[2] > this.scissor[3] {
                rect[2] = this.scissor[3]
            }

            if rect[3] > this.scissor[4] {
                rect[3] = this.scissor[4]
            }
        }


        y = rect[1]; for y < rect[3], y++ {
            if y >= this.height || y < 0 {
                continue
            }
            x = rect[0]; for x < rect[2], x++ {
                if x >= this.width || x < 0 {
                    continue
                }

                dx = <float>x - <float>pos[0]
                dy = <float>y - <float>pos[1]
                d = sqrt(dx*dx + dy*dy)
                if d > fradi {
                    continue
                }

                rColor = color

                if fradi - d < 1.0 {
                    rColor.a = <byte>((fradi - d) / 1.0 * <float><uint>color.a)
                }

                this.setPixel([x,y], rColor)
            }
        }
    }

    drawRoundedRect(pos [int, int], size [uint, uint], radi uint, color rgbColor) {
        if color.a == 0 {
            return
        }
        this.hasDrawn = true

        if radi * 2 > size[0] {
            radi = size[0] / 2
        }

        if radi * 2 > size[1] {
            radi = size[1] / 2
        }

        center = [pos[0] + size[0] / 2, pos[1] + size[1] / 2]
        corners = [size[0] / 2 - radi, size[1] / 2 - radi]
        y=pos[1]; for y < pos[1] + size[1], y++ {
            if y >= this.height || y < 0 {
                continue
            }
            x = pos[0]; for x < pos[0] + size[0], x++ {
                if x >= this.width || x < 0 {
                    continue
                }

                dx = x - center[0]
                dy = y - center[1]

                if dx < 0 {
                    dx = 0 - dx
                }

                if dy < 0 {
                    dy = 0 - dy
                }

                if dx > corners[0] && dy > corners[1] {
                    continue
                }


                this.setPixel([x,y], color)
            }

        }

        fradi = <float>radi
        
        cPos = [pos[0] + radi - 1, pos[1] + radi - 1]

        y=cPos[1] - radi; for y <= cPos[1], y++ {
            if y >= this.height || y < 0 {
                continue
            }
            x = cPos[0] - radi; for x <= cPos[0], x++ {
                if x >= this.width || x < 0 {
                    continue
                }

                dx = <float>x - <float>cPos[0]
                dy = <float>y - <float>cPos[1]
                d = sqrt(dx*dx + dy*dy)
                if d > fradi {
                    continue
                }

                rColor = color

                if fradi - d < 1.0 {
                    rColor.a = <byte>((fradi - d) / 1.0 * <float><uint>color.a)
                }

                this.setPixel([x,y], rColor)
            }
        }

        cPos = [pos[0] + size[0] - radi, pos[1] + radi - 1]

        y=cPos[1] - radi; for y <= cPos[1], y++ {
            if y >= this.height || y < 0 {
                continue
            }
            x = cPos[0]
            if size[0] % 2 == 0 {
                x++
            }

            for x < cPos[0] + radi, x++ {
                if x >= this.width || x < 0 {
                    continue
                }

                dx = <float>x - <float>cPos[0]
                dy = <float>y - <float>cPos[1]
                d = sqrt(dx*dx + dy*dy)
                if d > fradi {
                    continue
                }

                rColor = color

                if fradi - d < 1.0 {
                    rColor.a = <byte>((fradi - d) / 1.0 * <float><uint>color.a)
                }

                this.setPixel([x,y], rColor)
            }
        }

        cPos = [pos[0] + radi - 1, pos[1] + size[1] - radi]

        y=cPos[1]

        if size[1] % 2 == 0 {
            y++
        }

        for y < cPos[1] + radi, y++ {
            if y >= this.height || y < 0 {
                continue
            }
            
            x = cPos[0] - radi; for x <= cPos[0], x++ {
                if x >= this.width || x < 0 {
                    continue
                }

                dx = <float>x - <float>cPos[0]
                dy = <float>y - <float>cPos[1]
                d = sqrt(dx*dx + dy*dy)
                if d > fradi {
                    continue
                }

                rColor = color

                if fradi - d < 1.0 {
                    rColor.a = <byte>((fradi - d) / 1.0 * <float><uint>color.a)
                }

                this.setPixel([x,y], rColor)
            }
        }

        cPos = [pos[0] + size[0] - radi, pos[1] + size[1] - radi]

        y=cPos[1]

        if size[1] % 2 == 0 {
            y++
        }

        for y < cPos[1] + radi, y++ {
            if y >= this.height || y < 0 {
                continue
            }
            x = cPos[0]
            if size[0] % 2 == 0 {
                x++
            }
            for x < cPos[0] + radi, x++ {
                if x >= this.width || x < 0 {
                    continue
                }

                dx = <float>x - <float>cPos[0]
                dy = <float>y - <float>cPos[1]
                d = sqrt(dx*dx + dy*dy)
                if d > fradi {
                    continue
                }

                rColor = color

                if fradi - d < 1.0 {
                    rColor.a = <byte>((fradi - d) / 1.0 * <float><uint>color.a)
                }

                this.setPixel([x,y], rColor)
            }
        }

        // this.drawCircle([pos[0] + radi - 1, pos[1] + radi - 1], radi, color)
        // this.drawCircle([pos[0] + size[0] - radi, pos[1] + radi - 1], radi, color)
        // this.drawCircle([pos[0] + radi - 1, pos[1] + size[1] - radi], radi, color)
        // this.drawCircle([pos[0] + size[0] - radi, pos[1] + size[1] - radi], radi, color)
    }

    drawText(fnt font, text str, color rgbColor, pos [int, int]) [int,int] {
        fnt.currX = pos[0]
        fnt.currY = pos[1]
        this.hasDrawn = true

        i=0

        if this.scissor[0] && fnt.currY < this.scissor[2] {
            for i < len(text), i++ {

                if text[i] == <char>10 {
                    fnt.currY += fnt.fontSize + fnt.fontSize / 2
                    i++
                }

                if fnt.currY >= this.scissor[2] {
                    break
                }
            }
        }

        for i < len(text), i++ {

            if this.scissor[0] {
                if fnt.currY - fnt.fontSize >= this.scissor[4] {
                    break
                }

                if fnt.currX >= this.scissor[3] {
                    i++
                    for i < len(text), i++ {
                        if text[i] == <char>10 {
                            break
                        }
                    }

                    if i == len(text) {
                        break
                    }
                }
            }


            codePoint = <uint32>text[i]

            if text[i] == <char>10 {
                fnt.currX = pos[0]
                fnt.currY += fnt.fontSize + fnt.fontSize / 2
                continue
            }

            if text[i] & 0x80 != 0 && i+1 < len(text) && text[i+1] & 0xC0 == 0x80 {
                if text[i] & 0xE0 == 0xC0 {
                    codePoint = <uint32>((text[i] & 0x1F) << 6) | <uint32>(text[i+1] & 0x3F)
                    i++
                } else if text[i] & 0xF0 == 0xE0 && i+2 < len(text) {
                    codePoint = <uint32>((text[i] & 0x0F) << 12) | <uint32>((text[i+1] & 0x1F) << 6) | <uint32>(text[i+2] & 0x3F)
                    i += 2
                } else if text[i] & 0xF8 == 0xF0 && i+3 < len(text) {
                    codePoint = <uint32>((text[i] & 0x07) << 18) | <uint32>((text[i+1] & 0x0F) << 12) | <uint32>((text[i+2] & 0x1F) << 6) | <uint32>(text[i+3] & 0x3F)
                    i += 3
                }
            }


            fnt.writeChar(codePoint, color, this.setPixel, this)
        }

        return [fnt.currX, fnt.currY]
    }

    drawChar(fnt font, c uint32, color rgbColor, pos [int,int]) [int,int] {
        fnt.currX = pos[0]
        fnt.currY = pos[1]
        this.hasDrawn = true
        fnt.writeChar(c, color, this.setPixel, this)
        return [fnt.currX, fnt.currY]
    }

    drawByteArr(fnt font, text []byte, from uint, to uint, color rgbColor, pos [int, int]) {
        fnt.currX = pos[0]
        fnt.currY = pos[1]
        this.hasDrawn = true
        i=from; for i < to, i++ {
            codePoint = <uint32>text[i]

            if this.scissor[0] {
                if fnt.currY - fnt.fontSize >= this.scissor[4] {
                    break
                }

                if fnt.currX >= this.scissor[3] {
                    i++
                    for i < len(text), i++ {
                        if text[i] == <char>10 {
                            break
                        }
                    }

                    if i == len(text) {
                        break
                    }
                }
            }

            if text[i] == <char>10 {
                fnt.currX = pos[0]
                fnt.currY += fnt.fontSize + fnt.fontSize / 2
                continue
            }

            if text[i] & 0x80 != 0 && i+1 < len(text) && text[i+1] & 0xC0 == 0x80 {
                if text[i] & 0xE0 == 0xC0 {
                    codePoint = <uint32>((text[i] & 0x1F) << 6) | <uint32>(text[i+1] & 0x3F)
                    i++
                } else if text[i] & 0xF0 == 0xE0 && i+2 < len(text) {
                    codePoint = <uint32>((text[i] & 0x0F) << 12) | <uint32>((text[i+1] & 0x1F) << 6) | <uint32>(text[i+2] & 0x3F)
                    i += 2
                } else if text[i] & 0xF8 == 0xF0 && i+3 < len(text) {
                    codePoint = <uint32>((text[i] & 0x07) << 18) | <uint32>((text[i+1] & 0x0F) << 12) | <uint32>((text[i+2] & 0x1F) << 6) | <uint32>(text[i+3] & 0x3F)
                    i += 3
                }
            }

            fnt.writeChar(codePoint, color, this.setPixel, this)
        }
    }

    measureText(fnt font, text str) [uint, uint] {
        ocx = fnt.currX
        ocy = fnt.currY
        maxx = ocx
        fnt.currX = 0
        fnt.currY = 0
        i=0; for i < len(text), i++ {
            codePoint = <uint32>text[i]

            if text[i] == <char>10 {

                if fnt.currX > maxx {
                    maxx = fnt.currX
                }

                fnt.currX = ocx
                fnt.currY += fnt.fontSize + fnt.fontSize / 2
                continue
            }

            if text[i] & 0x80 != 0 && i+1 < len(text) && text[i+1] & 0xC0 == 0x80 {
                if text[i] & 0xE0 == 0xC0 {
                    codePoint = <uint32>((text[i] & 0x1F) << 6) | <uint32>(text[i+1] & 0x3F)
                    i++
                } else if text[i] & 0xF0 == 0xE0 && i+2 < len(text) {
                    codePoint = <uint32>((text[i] & 0x0F) << 12) | <uint32>((text[i+1] & 0x1F) << 6) | <uint32>(text[i+2] & 0x3F)
                    i += 2
                } else if text[i] & 0xF8 == 0xF0 && i+3 < len(text) {
                    codePoint = <uint32>((text[i] & 0x07) << 18) | <uint32>((text[i+1] & 0x0F) << 12) | <uint32>((text[i+2] & 0x1F) << 6) | <uint32>(text[i+3] & 0x3F)
                    i += 3
                }
            }

            fnt.measureChar(codePoint)
        }

        if fnt.currX > maxx {
            maxx = fnt.currX
        }

        res = [maxx, fnt.currY + fnt.fontSize]
        fnt.currX = ocx
        fnt.currY = ocy
        return res
    }

    measureByteArr(fnt font, text []byte, from uint, to uint) [uint, uint] {
        ocx = fnt.currX
        ocy = fnt.currY
        maxx = ocx
        fnt.currX = 0
        fnt.currY = 0
        i=from; for i < to, i++ {
            codePoint = <uint32>text[i]

            if text[i] == <char>10 {

                if fnt.currX > maxx {
                    maxx = fnt.currX
                }

                fnt.currX = ocx
                fnt.currY += fnt.fontSize + fnt.fontSize / 2
                continue
            }

            if text[i] & 0x80 != 0 && i+1 < len(text) && text[i+1] & 0xC0 == 0x80 {
                if text[i] & 0xE0 == 0xC0 {
                    codePoint = <uint32>((text[i] & 0x1F) << 6) | <uint32>(text[i+1] & 0x3F)
                    i++
                } else if text[i] & 0xF0 == 0xE0 && i+2 < len(text) {
                    codePoint = <uint32>((text[i] & 0x0F) << 12) | <uint32>((text[i+1] & 0x1F) << 6) | <uint32>(text[i+2] & 0x3F)
                    i += 2
                } else if text[i] & 0xF8 == 0xF0 && i+3 < len(text) {
                    codePoint = <uint32>((text[i] & 0x07) << 18) | <uint32>((text[i+1] & 0x0F) << 12) | <uint32>((text[i+2] & 0x1F) << 6) | <uint32>(text[i+3] & 0x3F)
                    i += 3
                }
            }

            fnt.measureChar(codePoint)
        }

        if fnt.currX > maxx {
            maxx = fnt.currX
        }

        res = [maxx, fnt.currY + fnt.fontSize]
        fnt.currX = ocx
        fnt.currY = ocy
        return res
    }

    toScreenCoord(pos [int,int]) [int,int] {
        cookie = xcb_translate_coordinates(this.connection,
        this.window,
        this.screen.root,
        pos[0], pos[1])

        reply = xcb_translate_coordinates_reply(this.connection, cookie, null)

        res = [<int>reply.dst_x, <int>reply.dst_y]
        free(reply)
        return res
    }


    clear(color rgbColor) {
        if this.scissor[0] {
            this.drawRect([this.scissor[1], this.scissor[2]], [this.scissor[3] - this.scissor[1], this.scissor[4] - this.scissor[2]], color)

            return
        }
        this.hasDrawn = true
        n = <uint32>color
        memset(this.frameBuffer, n, this.width * this.height * 4)
    }

    launch(width uint, height uint, title str) {

        this.haveFrame.init()
        this.haveFrameMut.init()
        this.clipboardChan = channel()

        this.isRunning = true

        threadWrkrFn = this.__drawThreadworker

        i=1; for i <= __graphicsNbDrawers, i++ {
            async threadWrkrFn(this, i)

        }

        this.width = width
        this.height = height
        screen_number = <int32>0
        this.connection = xcb_connect(null, &screen_number);
        if (xcb_connection_has_error(this.connection)) {
            xcb_disconnect(this.connection)
            return
        }

        setup = xcb_get_setup(this.connection)
        iter = xcb_setup_roots_iterator(setup)

        i=0; for i < screen_number, i++ {
            xcb_screen_next(&iter)
        }

        this.screen = iter.data

        this.window = xcb_generate_id(this.connection)
        value_mask = XCB_CW_BACK_PIXMAP | XCB_CW_EVENT_MASK

        value_list = [
            XCB_BACK_PIXMAP_NONE, XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_KEY_PRESS | XCB_EVENT_MASK_FOCUS_CHANGE | XCB_EVENT_MASK_KEY_RELEASE | XCB_EVENT_MASK_BUTTON_PRESS | XCB_EVENT_MASK_BUTTON_RELEASE | XCB_EVENT_MASK_POINTER_MOTION | XCB_EVENT_MASK_BUTTON_MOTION | XCB_EVENT_MASK_FOCUS_CHANGE | XCB_EVENT_MASK_STRUCTURE_NOTIFY
        ]

        xcb_create_window(
            this.connection,
            0,
            this.window,
            this.screen.root,
            0, 0, width, height,
            10,
            XCB_WINDOW_CLASS_INPUT_OUTPUT,
            this.screen.root_visual,
            value_mask, &value_list
        )

        xcb_change_property(
            this.connection,
            XCB_PROP_MODE_REPLACE,
            this.window,
            XCB_ATOM_WM_NAME,
            XCB_ATOM_STRING,
            8,
            len(title),
            cStr(title)
        )

        xcb_map_window(this.connection, this.window)
        xcb_flush(this.connection)

        size = width * height * 4

        shmid = shmget(0, size, 896)

        if shmid < 0 {
            panic("erorr allocating shared memory")
        }

        this.frameBuffer = shmat(shmid, null, 0)

        shminfo = xcb_shm_segment_info_t {
            shmseg: xcb_generate_id(this.connection)
            shmid: shmid
            shmaddr: this.frameBuffer
        }

        xcb_shm_attach(this.connection, shminfo.shmseg, shminfo.shmid, 0);
        xcb_flush(this.connection)

        this.keySyms = xcb_key_symbols_alloc(this.connection)

        xcb_cursor_context_new(this.connection, this.screen, &this.cursorCtx)

        event xcb_generic_event_t*

        gc = xcb_generate_id(this.connection)
        values = [0]
        xcb_create_gc(this.connection, gc, this.window, XCB_GC_GRAPHICS_EXPOSURES, &values)

        this.isExposed = false
        for true, event = xcb_wait_for_event(this.connection) {
            if event == null {
                if this.isExposed {
                    this.callEventFunction(windowEventClose)
                    break
                }
                continue
            }

            eventType = event.response_type & 0x7F

            if eventType == 22 {
                cfg = <xcb_configure_notify_event_t *>event
                if cfg.width == this.width && cfg.height == this.height {
                    continue
                }
                this.width  = cfg.width
                this.height = cfg.height

                xcb_shm_detach(this.connection, shminfo.shmseg)
                shmdt(this.frameBuffer)
                shmctl(shminfo.shmid, 0, null)

                size = this.width * this.height * 4;
                shminfo.shmid = shmget(0, size, 896)
                this.frameBuffer = shmat(shminfo.shmid, null, 0)
                shminfo.shmseg = xcb_generate_id(this.connection)

                xcb_shm_attach(this.connection, shminfo.shmseg, shminfo.shmid, 0)
                this.callEventFunction(windowEventResize)
                this.callEventFunction(windowEventDraw)
            } else if eventType == 12 {
                if this.isExposed == false {
                    this.callEventFunction(windowEventInitialize)
                    this.isExposed = true
                }

                this.hasDrawn = false
                this.callEventFunction(windowEventDraw)

                xcb_shm_put_image(
                    this.connection,
                    this.window,
                    gc,
                    this.width, this.height,
                    0, 0, this.width, this.height,
                    0, 0,
                    this.screen.root_depth,
                    XCB_IMAGE_FORMAT_Z_PIXMAP,
                    0,
                    shminfo.shmseg,
                    0
                )

                xcb_flush(this.connection)
                // c = xcb_get_input_focus(this.connection)
                // xcb_get_input_focus_reply(this.connection, c, null)
            } else if eventType == 6 {
                this.callEventFunction(windowEventMouseMove)
            } else if eventType == 4 {
                this.lastMouseCode = event.pad0
                this.callEventFunction(windowEventMouseDown)
            } else if eventType == 5 {
                this.lastMouseCode = event.pad0
                this.callEventFunction(windowEventMouseUp)
            } else if eventType == 2 {
                this.lastKeyCode = event.pad0

                if event.pad0 == 37 || event.pad0 == 105 {
                    this.keyModifiers = this.keyModifiers | 0x01 //ctrl
                } else if event.pad0 == 50 || event.pad0 == 62 {
                    this.keyModifiers = this.keyModifiers | 0x02 //shift
                } else if event.pad0 == 64 {
                    this.keyModifiers = this.keyModifiers | 0x04 //alt
                } else if event.pad0 == 108 {
                    this.keyModifiers = this.keyModifiers | 0x08 //altgr
                } else if event.pad0 == 66 {
                    this.shiftLock = this.shiftLock == false
                }
                this.callEventFunction(windowEventKeyDown)
            } else if eventType == 3 {
                this.lastKeyCode = event.pad0

                if event.pad0 == 37 || event.pad0 == 105 {
                    this.keyModifiers = this.keyModifiers & ~0x01
                } else if event.pad0 == 50 || event.pad0 == 62 {
                    this.keyModifiers = this.keyModifiers & ~0x02
                } else if event.pad0 == 64 {
                    this.keyModifiers = this.keyModifiers & ~0x04
                } else if event.pad0 == 108 {
                    this.keyModifiers = this.keyModifiers & ~0x08
                }
                this.callEventFunction(windowEventKeyUp)
            } else if eventType == 33 {
                break
            } else if eventType == 30 {
                req = <xcb_selection_request_event_t*>event

                notify = xcb_selection_notify_event_t {
                    response_type: 31
                    time: req.time
                    requestor: req.requestor
                    selection: req.selection
                    target: req.target
                    property: req.property
                }

                if req.property == 0 {
                    notify.property = 0
                } else {
                    xcb_change_property(
                        this.connection,
                        XCB_PROP_MODE_REPLACE,
                        req.requestor,
                        req.property,
                        req.target,
                        8,
                        len(this.tmpClipboard),
                        cStr(this.tmpClipboard)
                    )
                }
                xcb_send_event(this.connection, 0, req.requestor, 0, <ptr>&notify)
                xcb_flush(this.connection)
            } else if eventType == 31 {
                cookie = xcb_get_property(
                    this.connection, 0,
                    this.window,
                    this.tmpClipboardAtoms[0],
                    this.tmpClipboardAtoms[1], 0, 100000
                )
                prop = xcb_get_property_reply(this.connection, cookie, null)

                if prop != null {
                    l = xcb_get_property_value_length(prop)
                    res = memoryAllocSTR(l + 5)
                    *(<uint32*>res) = l
                    memcpy(<ptr>(<uint>res + 4), xcb_get_property_value(prop), l)
                    free(prop)
                    xcb_delete_property(this.connection, this.window, this.tmpClipboardAtoms[0])
                    this.clipboardChan.send(res)
                }
            } else if eventType == 9 {
                this.callEventFunction(windowEventFocusIn)
            } else if eventType == 10 {
                this.callEventFunction(windowEventFocusOut)
            }
            //  else {
            //     println("unkown event: "+intToStr(eventType))
            // }

            free(event)
        }

        this.isRunning = false
        this.haveFrame.broadcast()

        xcb_cursor_context_free(this.cursorCtx)
        xcb_shm_detach(this.connection, shminfo.shmseg)
        shmdt(this.frameBuffer)
        shmctl(shmid, 0, null)
        xcb_key_symbols_free(this.keySyms)
        xcb_disconnect(this.connection)

        this.haveFrame.destroy()
        this.haveFrameMut.destroy()
        this.clipboardChan.destroy()
    }

}